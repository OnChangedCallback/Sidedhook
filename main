-- variables
local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local game, workspace = game, workspace
local Vector3, Vector2, CFrame, Color3, Instance = Vector3, Vector2, CFrame, Color3, Instance
local Enum = Enum
local math, tick, pairs, pcall, tostring, tonumber, ipairs, table = math, tick, pairs, pcall, tostring, tonumber, ipairs, table
local getrawmetatable, setreadonly, checkcaller, hookmetamethod, newcclosure, getnamecallmethod, hookfunction, debug, getconnections = getrawmetatable, setreadonly, checkcaller, hookmetamethod, newcclosure, getnamecallmethod, hookfunction, debug, getconnections
local loadstring, setclipboard = loadstring, setclipboard
local TeleportService, HttpService, Players, RunService, UserInputService = game:GetService("TeleportService"), game:GetService("HttpService"), game:GetService("Players"), game:GetService("RunService"), game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local random = math.random

-- multi weapon variables
local allowed_tools = {
    ["[AUG]"] = true,
    ["[Rifle]"] = true,
    ["[LMG]"] = true,
    ["[P90]"] = true,
    ["[Flintlock]"] = true,
    ["[Revolver]"] = true,
    ["[Double-Barrel SG]"] = true,
    ["[AK47]"] = true,
    ["[TacticalShotgun]"] = true,
}

-- forcehit variables
local forceHitTarget = {
    enabled = false,
    position = Vector3.new(0, 0, 0),
    part = nil
}

-- nospread variables
local spreadMod = {
    enabled = false,
    amount = 100
}

-- rapidfire variables
local rapidFireMod = {
    enabled = false,
    speed = 0.00000000000000000001
}

-- hitbox expander variables
local hitboxExpanderMod = {
    enabled = false,
    size = 20,
    visible = false,
    color = Color3.new(1, 0, 0)
}

-- infinity range variables
local infinityRangeMod = {
    enabled = false
}

-- auto reload variables
local autoReloadMod = {
    enabled = false,
    reloadDelay = 1.0
}

local Hooks = {}

loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/Sidedhook/refs/heads/main/antileak"))()
loadstring(game:HttpGet("https://pastebin.com/raw/gimbTwW1"))()

-- silent aim hook (separate from forcehit)
do
    local Mouse = LocalPlayer:GetMouse()
    local MetaTable = getrawmetatable(game)
    local OldIndex = MetaTable.__index
    setreadonly(MetaTable, false)
    
    MetaTable.__index = function(self, key)
        if not checkcaller() and self == Mouse and _G.silent_aim_enabled then
            if key == "Hit" or key == "Target" then
                local targetPlayer = _G.targeting_state.current
                if targetPlayer and targetPlayer.Character then
                    local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if targetPart then
                        local finalPos = targetPart.Position
                        if _G.predictPosition then
                            local predictedPos = _G.predictPosition(targetPlayer)
                            if predictedPos then
                                finalPos = predictedPos
                                local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                                if humanoid then
                                    if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
                                        finalPos = finalPos + Vector3.new(0, 2, 0)
                                    elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                                        finalPos = finalPos + Vector3.new(0, -1, 0)
                                    end
                                end
                            end
                        end
                        return key == "Hit" and CFrame.new(finalPos) or targetPart
                    end
                end
            end
        end
        return OldIndex(self, key)
    end
    setreadonly(MetaTable, true)
end

-- forcehit hook (separate from silent aim)
do
    Hooks.Remote = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        local args = { ... }
        local method = getnamecallmethod():lower()

        if forceHitTarget.enabled and forceHitTarget.position and forceHitTarget.part and 
           method == 'fireserver' and self.Name == 'MainRemoteEvent' and args[1] == 'ShootGun' then
            args[3] = forceHitTarget.position
            args[5] = forceHitTarget.part
            args[6] = Vector3.new(0, 0, -1)
            return Hooks.Remote(self, unpack(args))
        end

        return Hooks.Remote(self, ...)
    end))
end

-- library initialization
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

-- window creation
local Window = Library:CreateWindow({
    Title = 'RAZE.pub',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

-- tabs
local Tabs = {
    ['Rage'] = Window:AddTab('Rage'),
    ['UI Settings'] = Window:AddTab('Settings'),
    
}

do -- ui settings configuration
    -- ui settings tab
    do
        local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
        
        MenuGroup:AddButton('Unload', function() 
            Library:Unload() 
        end)
        
        MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { 
            Default = 'End', 
            NoUI = true, 
            Text = 'Menu keybind' 
        })
        
        Library.ToggleKeybind = Options.MenuKeybind
        
        -- managers setup
        ThemeManager:SetLibrary(Library)
        SaveManager:SetLibrary(Library)
        SaveManager:IgnoreThemeSettings()
        SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
        
        -- folders
        ThemeManager:SetFolder('MyScriptHub')
        SaveManager:SetFolder('MyScriptHub/specific-game')
        
        -- build sections
        SaveManager:BuildConfigSection(Tabs['UI Settings'])
        ThemeManager:ApplyToTab(Tabs['UI Settings'])
        
        -- autoload
        SaveManager:LoadAutoloadConfig()
    end

    -- server groupbox
    do
        local ServerGroup = Tabs['UI Settings']:AddRightGroupbox('Server')
        
        ServerGroup:AddButton({
            Text = 'Copy GameID',
            Func = function()
                setclipboard(tostring(game.GameId))
                Library:Notify('GameID copied to clipboard', 2)
            end,
            Tooltip = '>_<'
        })
        
        ServerGroup:AddButton({
            Text = 'Copy JobID', 
            Func = function()
                setclipboard(game.JobId)
                Library:Notify('JobID copied to clipboard', 2)
            end,
            Tooltip = '>_<'
        })
        
        ServerGroup:AddButton({
            Text = 'Copy Join Script',
            Func = function()
                local joinScript = 'game:GetService("TeleportService"):TeleportToPlaceInstance(' .. 
                                  game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)'
                setclipboard(joinScript)
                Library:Notify('Join script copied to clipboard', 2)
            end,
            Tooltip = '>_<'
        })
        
        ServerGroup:AddButton({
            Text = 'Rejoin Game',
            Func = function()
                TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
            end,
            Tooltip = '>_<'
        })
        
        ServerGroup:AddButton({
            Text = 'Join New Server',
            Func = function()
                local success, serverData = pcall(function()
                    return HttpService:JSONDecode(
                        game:HttpGetAsync(
                            "https://games.roblox.com/v1/games/" .. 
                            game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
                        )
                    )
                end)
                
                if success and serverData and serverData.data and #serverData.data > 0 then
                    local randomServer = serverData.data[math.random(1, #serverData.data)]
                    TeleportService:TeleportToPlaceInstance(game.PlaceId, randomServer.id)
                else
                    Library:Notify('nope', 3)
                end
            end,
            Tooltip = '>_<'
        })
    end

    -- hud groupbox
    do
        local HUDGroup = Tabs['UI Settings']:AddRightGroupbox('HUD')
        
        HUDGroup:AddToggle('Watermark', {
            Text = 'Watermark',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                if value then
                    Library:SetWatermark('Clientsidedhook.pub | ' .. os.date('%d.%m.%Y'))
                end
                Library:SetWatermarkVisibility(value)
            end
        })
        
        HUDGroup:AddToggle('KeybindList', {
            Text = 'Keybind List',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                Library.KeybindFrame.Visible = value
            end
        })
    end
end

do -- rage tab configuration
    -- targeting framework
    do
        local targeting_state = {current = nil}
        pcall(function()
            _G.targeting_state = targeting_state
        end)
        
        local utility = {}
        
        function utility:ValidateClient(player)
            if not player then return false end
            local character = player.Character
            if not character then return false end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0 then return false end
            return humanoid.RootPart ~= nil
        end
        
        function utility:GetPreferredPart(character)
            return character and 
                (character:FindFirstChild("HumanoidRootPart") or 
                 character:FindFirstChild("Head") or 
                 character:FindFirstChild("UpperTorso") or
                 character:FindFirstChild("Torso")) or nil
        end
        
        function utility:ToScreen(position)
            local camera = workspace.CurrentCamera
            local screenPos, onScreen = camera:WorldToViewportPoint(position)
            return Vector2.new(screenPos.X, screenPos.Y), onScreen
        end
        
        function utility:GetMouseLocation()
            local UserInputService = game:GetService("UserInputService")
            return UserInputService:GetMouseLocation()
        end
        
        function utility:GetMouseDistance(screenPos)
            return (utility:GetMouseLocation() - screenPos).Magnitude
        end
        
        function utility:isPlayerKO(player)
            if not player or not player.Character then return false end
            
            -- Проверяем K.O статус через BodyEffects
            local success, isKO = pcall(function()
                local playerInWorkspace = workspace.Players:FindFirstChild(player.Name)
                if playerInWorkspace and playerInWorkspace:FindFirstChild("BodyEffects") then
                    local koEffect = playerInWorkspace.BodyEffects:FindFirstChild("K.O")
                    if koEffect and koEffect.value then
                        return koEffect.value == true
                    end
                end
                return false
            end)
            
            if success then
                return isKO
            end
            
            -- Fallback к проверке здоровья если BodyEffects недоступны
            local humanoid = player.Character:FindFirstChild("Humanoid")
            return humanoid and humanoid.Health <= 0
        end
        
        local framework = {}
        
        function framework:GetClosestTarget()
            local closest = nil
            local shortestDistance = math.huge
            local mousePos = utility:GetMouseLocation()
            
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and utility:ValidateClient(player) then
                    -- Проверяем, нужно ли пропускать цель с K.O статусом
                    if _G.skip_ko and utility:isPlayerKO(player) then
                        -- Пропускаем игрока с K.O статусом
                    else
                        local character = player.Character
                        local part = utility:GetPreferredPart(character)
                        if part then
                            local screenPos, onScreen = utility:ToScreen(part.Position)
                            if onScreen then
                                local distance = utility:GetMouseDistance(screenPos)
                                if distance < shortestDistance then
                                    shortestDistance = distance
                                    closest = player
                                end
                            end
                        end
                    end
                end
            end
            
            return closest
        end
        
        function framework:SetTarget(player)
            if utility:ValidateClient(player) then
                targeting_state.current = player
                local koStatus = utility:isPlayerKO(player)
                Library:Notify('ragetbot set to: ' .. player.Name .. ' | isKO: ' .. tostring(koStatus), 2)
                return true
            else
                targeting_state.current = nil
                Library:Notify('Invalid target', 2)
                return false
            end
        end
        
        function framework:GetCurrentTarget()
            if targeting_state.current and utility:ValidateClient(targeting_state.current) then
                return targeting_state.current
            else
                targeting_state.current = nil
                return nil
            end
        end
        
        function framework:UpdateTarget()
            local current = targeting_state.current
            if current and not utility:ValidateClient(current) then
                -- Цель умерла или недоступна, ищем новую
                local newTarget = framework:GetClosestTarget()
                if newTarget then
                    framework:SetTarget(newTarget)
                else
                    targeting_state.current = nil
                    Library:Notify('No valid targets', 2)
                end
            end
        end
        
        _G.targeting_framework = framework
    end
    
    -- nospread utility
    do
        local noSpreadUtility = {}
        local weaponHooks = {}
        
        function noSpreadUtility:markWeapon(tool)
            if not tool or not tool:IsA("Tool") then return false end
            
            -- Создаем файл с именем равным значению spread
            local spreadFile = Instance.new("StringValue")
            spreadFile.Name = tostring(spreadMod.amount)
            spreadFile.Value = "nospread_marker"
            spreadFile.Parent = tool
            
            return true
        end
        
        function noSpreadUtility:isWeaponMarked(tool)
            if not tool or not tool:IsA("Tool") then return false end
            
            -- Ищем любой файл-маркер spread
            for _, child in pairs(tool:GetChildren()) do
                if child:IsA("StringValue") and child.Value == "nospread_marker" then
                    return true, tonumber(child.Name) or 100
                end
            end
            return false, 100
        end
        
        function noSpreadUtility:updateWeaponSpread(tool)
            if not tool or not tool:IsA("Tool") then return end
            
            local isMarked, currentSpread = noSpreadUtility:isWeaponMarked(tool)
            if isMarked and currentSpread ~= spreadMod.amount then
                -- Удаляем старый маркер
                for _, child in pairs(tool:GetChildren()) do
                    if child:IsA("StringValue") and child.Value == "nospread_marker" then
                        child:Destroy()
                    end
                end
                -- Создаем новый с актуальным значением
                noSpreadUtility:markWeapon(tool)
            end
        end
        
        function noSpreadUtility:createHook()
            if weaponHooks.mathRandom then return end
            
            weaponHooks.mathRandom = hookfunction(random, function(...)
                local args = {...}
                
                if checkcaller() then
                    return weaponHooks.mathRandom(...)
                end
                
                -- Проверяем любое оружие без ограничений
                local character = LocalPlayer.Character
                if character then
                    local tool = character:FindFirstChildOfClass("Tool")
                    if tool and spreadMod.enabled then
                        local isMarked, toolSpread = noSpreadUtility:isWeaponMarked(tool)
                        
                        -- Автоматически маркируем новые оружия при взятии в руки
                        if not isMarked then
                            noSpreadUtility:markWeapon(tool)
                            isMarked = true
                        end
                        
                        if isMarked then
                            -- Обновляем spread файл если нужно
                            noSpreadUtility:updateWeaponSpread(tool)
                            
                            -- Проверяем паттерны spread вызовов
                            if (#args == 0) or 
                               (args[1] == -0.05 and args[2] == 0.05) or 
                               (args[1] == -0.1) or
                               (args[1] == -0.05) then
                                
                                local spread = spreadMod.amount
                                return weaponHooks.mathRandom(...) * (spread / 100)
                            end
                        end
                    end
                end
                
                return weaponHooks.mathRandom(...)
            end)
        end
        
        function noSpreadUtility:removeHook()
            -- Не удаляем хук, только отключаем его работу через spreadMod.enabled
        end
        
        function noSpreadUtility:enable()
            noSpreadUtility:createHook()
            
            -- Маркируем текущее оружие если есть (любое оружие)
            local character = LocalPlayer.Character
            if character then
                local tool = character:FindFirstChildOfClass("Tool")
                if tool then
                    noSpreadUtility:markWeapon(tool)
                end
            end
        end
        
        function noSpreadUtility:disable()
            -- Не убираем маркеры, только отключаем через spreadMod.enabled
        end
        
        function noSpreadUtility:markAllWeapons()
            -- Маркируем все оружия в персонаже
            local character = LocalPlayer.Character
            if character then
                for _, tool in pairs(character:GetChildren()) do
                    if tool:IsA("Tool") then
                        local isMarked = noSpreadUtility:isWeaponMarked(tool)
                        if not isMarked then
                            noSpreadUtility:markWeapon(tool)
                        else
                            noSpreadUtility:updateWeaponSpread(tool)
                        end
                    end
                end
            end
            
            -- Маркируем все оружия в рюкзаке
            local backpack = LocalPlayer:FindFirstChild("Backpack")
            if backpack then
                for _, tool in pairs(backpack:GetChildren()) do
                    if tool:IsA("Tool") then
                        local isMarked = noSpreadUtility:isWeaponMarked(tool)
                        if not isMarked then
                            noSpreadUtility:markWeapon(tool)
                        else
                            noSpreadUtility:updateWeaponSpread(tool)
                        end
                    end
                end
            end
        end
        
        _G.NoSpreadUtility = noSpreadUtility
    end
    
    -- rapidfire utility
    do
        local rapidFireUtility = {}
        local originalValues = {}
        local renderConnection = nil
        
        function rapidFireUtility:markWeapon(tool)
            if not tool or not tool:IsA("Tool") then return false end
            
            -- Создаем файл с именем равным значению speed
            local speedFile = Instance.new("StringValue")
            speedFile.Name = tostring(rapidFireMod.speed)
            speedFile.Value = "rapidfire_marker"
            speedFile.Parent = tool
            
            return true
        end
        
        function rapidFireUtility:isWeaponMarked(tool)
            if not tool or not tool:IsA("Tool") then return false end
            
            -- Ищем любой файл-маркер rapidfire
            for _, child in pairs(tool:GetChildren()) do
                if child:IsA("StringValue") and child.Value == "rapidfire_marker" then
                    return true, child.Name
                end
            end
            return false, nil
        end
        
        function rapidFireUtility:updateWeaponSpeed(tool)
            if not tool or not tool:IsA("Tool") then return end
            
            local isMarked, currentSpeed = rapidFireUtility:isWeaponMarked(tool)
            if isMarked and currentSpeed ~= tostring(rapidFireMod.speed) then
                -- Удаляем старый маркер
                for _, child in pairs(tool:GetChildren()) do
                    if child:IsA("StringValue") and child.Value == "rapidfire_marker" then
                        child:Destroy()
                    end
                end
                -- Создаем новый с актуальным значением
                rapidFireUtility:markWeapon(tool)
            end
        end
        
        function rapidFireUtility:processWeapon(tool)
            if not tool or not tool:FindFirstChild("GunScript") then return end
            
            local isMarked = rapidFireUtility:isWeaponMarked(tool)
            if not isMarked then return end
            
            -- Обновляем маркер если нужно
            rapidFireUtility:updateWeaponSpeed(tool)
            
            -- Обрабатываем connections только если RapidFire включен
            if rapidFireMod.enabled then
                for _, connection in ipairs(getconnections(tool.Activated)) do
                    local func = connection.Function
                    if func then
                        local funcInfo = debug.getinfo(func)
                        for i = 1, funcInfo.nups do
                            local c, n = debug.getupvalue(func, i)
                            if type(c) == "number" then
                                -- Сохраняем оригинальное значение
                                local key = tostring(func) .. "_" .. i
                                if not originalValues[key] then
                                    originalValues[key] = c
                                end
                                -- Устанавливаем новое значение
                                debug.setupvalue(func, i, rapidFireMod.speed)
                            end
                        end
                    end
                end
            else
                -- Восстанавливаем оригинальные значения если RapidFire выключен
                for _, connection in ipairs(getconnections(tool.Activated)) do
                    local func = connection.Function
                    if func then
                        local funcInfo = debug.getinfo(func)
                        for i = 1, funcInfo.nups do
                            local c, n = debug.getupvalue(func, i)
                            if type(c) == "number" then
                                local key = tostring(func) .. "_" .. i
                                if originalValues[key] then
                                    debug.setupvalue(func, i, originalValues[key])
                                end
                            end
                        end
                    end
                end
            end
        end
        
        function rapidFireUtility:enable()
            if renderConnection then return end
            
            -- Маркируем все оружия
            rapidFireUtility:markAllWeapons()
            
            -- Создаем RenderStepped connection
            renderConnection = RunService.RenderStepped:Connect(function()
                local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
                if tool then
                    -- Автоматически маркируем новые оружия при взятии в руки
                    local isMarked = rapidFireUtility:isWeaponMarked(tool)
                    if not isMarked then
                        rapidFireUtility:markWeapon(tool)
                    end
                    rapidFireUtility:processWeapon(tool)
                end
            end)
        end
        
        function rapidFireUtility:disable()
            -- Отключаем RenderStepped connection
            if renderConnection then
                renderConnection:Disconnect()
                renderConnection = nil
            end
            
            -- Восстанавливаем оригинальные значения для всех оружий
            local character = LocalPlayer.Character
            if character then
                for _, tool in pairs(character:GetChildren()) do
                    if tool:IsA("Tool") and tool:FindFirstChild("GunScript") then
                        rapidFireUtility:restoreOriginalValues(tool)
                    end
                end
            end
            
            local backpack = LocalPlayer:FindFirstChild("Backpack")
            if backpack then
                for _, tool in pairs(backpack:GetChildren()) do
                    if tool:IsA("Tool") and tool:FindFirstChild("GunScript") then
                        rapidFireUtility:restoreOriginalValues(tool)
                    end
                end
            end
            
            -- Удаляем все маркеры RapidFire
            rapidFireUtility:removeAllMarkers()
            
            -- Очищаем сохраненные оригинальные значения
            originalValues = {}
        end
        
        function rapidFireUtility:restoreOriginalValues(tool)
            if not tool or not tool:FindFirstChild("GunScript") then return end
            
            for _, connection in ipairs(getconnections(tool.Activated)) do
                local func = connection.Function
                if func then
                    local funcInfo = debug.getinfo(func)
                    for i = 1, funcInfo.nups do
                        local c, n = debug.getupvalue(func, i)
                        if type(c) == "number" then
                            local key = tostring(func) .. "_" .. i
                            if originalValues[key] then
                                debug.setupvalue(func, i, originalValues[key])
                                originalValues[key] = nil -- Удаляем после восстановления
                            end
                        end
                    end
                end
            end
        end
        
        function rapidFireUtility:removeAllMarkers()
            -- Удаляем маркеры со всех оружий в персонаже
            local character = LocalPlayer.Character
            if character then
                for _, tool in pairs(character:GetChildren()) do
                    if tool:IsA("Tool") then
                        for _, child in pairs(tool:GetChildren()) do
                            if child:IsA("StringValue") and child.Value == "rapidfire_marker" then
                                child:Destroy()
                            end
                        end
                    end
                end
            end
            
            -- Удаляем маркеры со всех оружий в рюкзаке
            local backpack = LocalPlayer:FindFirstChild("Backpack")
            if backpack then
                for _, tool in pairs(backpack:GetChildren()) do
                    if tool:IsA("Tool") then
                        for _, child in pairs(tool:GetChildren()) do
                            if child:IsA("StringValue") and child.Value == "rapidfire_marker" then
                                child:Destroy()
                            end
                        end
                    end
                end
            end
        end
        
        function rapidFireUtility:markAllWeapons()
            -- Маркируем все оружия в персонаже
            local character = LocalPlayer.Character
            if character then
                for _, tool in pairs(character:GetChildren()) do
                    if tool:IsA("Tool") then
                        local isMarked = rapidFireUtility:isWeaponMarked(tool)
                        if not isMarked then
                            rapidFireUtility:markWeapon(tool)
                        else
                            rapidFireUtility:updateWeaponSpeed(tool)
                        end
                    end
                end
            end
            
            -- Маркируем все оружия в рюкзаке
            local backpack = LocalPlayer:FindFirstChild("Backpack")
            if backpack then
                for _, tool in pairs(backpack:GetChildren()) do
                    if tool:IsA("Tool") then
                        local isMarked = rapidFireUtility:isWeaponMarked(tool)
                        if not isMarked then
                            rapidFireUtility:markWeapon(tool)
                        else
                            rapidFireUtility:updateWeaponSpeed(tool)
                        end
                    end
                end
            end
        end
        
        _G.RapidFireUtility = rapidFireUtility
    end
    
    -- forcehit functionality
    do
        local function updateForceHitTarget()
            -- Всегда сначала проверяем глобальный тогл
            if not _G.forcehit_enabled then
                forceHitTarget.enabled = false
                forceHitTarget.position = Vector3.new(0, 0, 0)
                forceHitTarget.part = nil
                return
            end
            
            local targetPlayer = _G.targeting_state.current
            if targetPlayer and targetPlayer.Character then
                local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                
                if targetPart then
                    forceHitTarget.enabled = true
                    forceHitTarget.position = targetPart.Position
                    forceHitTarget.part = targetPart
                else
                    forceHitTarget.enabled = false
                    forceHitTarget.position = Vector3.new(0, 0, 0)
                    forceHitTarget.part = nil
                end
            else
                forceHitTarget.enabled = false
                forceHitTarget.position = Vector3.new(0, 0, 0)
                forceHitTarget.part = nil
            end
        end
        
        _G.updateForceHitTarget = updateForceHitTarget
    end
    
    -- magic bullets utility
    do
        local magicUtility = {}
        
        function magicUtility:getSelectedTarget()
            local mode = _G.magic_bullets_mode or "Target"
            
            if mode == "Target" then
                -- Используем выбранную цель из системы таргетинга
                if not _G.targeting_state or not _G.targeting_state.current then
                    return nil
                end
                
                local targetPlayer = _G.targeting_state.current
                if not targetPlayer or not targetPlayer.Character then
                    return nil
                end
                
                local target_head = targetPlayer.Character:FindFirstChild("Head")
                return target_head
            elseif mode == "Killaura" then
                -- Находим ближайшую цель для killaura режима
                local framework = _G.targeting_framework
                if not framework then return nil end
                
                local closestTarget = framework:GetClosestTarget()
                if not closestTarget or not closestTarget.Character then
                    return nil
                end
                
                local target_head = closestTarget.Character:FindFirstChild("Head")
                return target_head
            end
            
            return nil
        end
        
        function magicUtility:performShoot(target)
            if not target then return false end
            
            -- Проверяем K.O статус цели перед выстрелом
            local targetPlayer = nil
            local mode = _G.magic_bullets_mode or "Target"
            
            if mode == "Target" then
                targetPlayer = _G.targeting_state.current
            elseif mode == "Killaura" then
                -- Находим игрока по target части
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character then
                        local head = player.Character:FindFirstChild("Head")
                        if head == target then
                            targetPlayer = player
                            break
                        end
                    end
                end
            end
            
            if targetPlayer and targetPlayer.Character then
                local checks = _G.magic_bullets_checks or {}
                
                -- Проверка K.O статуса (если включена)
                if checks['K.O'] then
                    local bodyEffects = targetPlayer.Character:FindFirstChild("BodyEffects")
                    if bodyEffects and bodyEffects:FindFirstChild("K.O") then
                        if bodyEffects["K.O"].Value then
                            return false -- Цель в K.O, не стреляем
                        end
                    end
                end
                
                -- Проверка Forcefield (если включена)
                if checks['Forcefield'] then
                    local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid:FindFirstChild("ForceField") then
                        return false -- У цели есть forcefield, не стреляем
                    end
                end
                
                -- Проверка Grabbed статуса (если включена)
                if checks['Grabbed'] then
                    local bodyEffects = targetPlayer.Character:FindFirstChild("BodyEffects")
                    if bodyEffects and bodyEffects:FindFirstChild("Grabbed") then
                        if bodyEffects["Grabbed"].Value then
                            return false -- Цель схвачена, не стреляем
                        end
                    end
                end
            end
            
            local character = LocalPlayer.Character
            if not character then return false end
            
            local tool = character:FindFirstChildOfClass("Tool")
            if not tool or not tool:FindFirstChild("Handle") then return false end
            
            -- Получаем MainRemoteEvent
            local replicatedStorage = game:GetService("ReplicatedStorage")
            local mainRemotes = replicatedStorage:FindFirstChild("MainRemotes")
            if not mainRemotes then return false end
            
            local mainRemoteEvent = mainRemotes:FindFirstChild("MainRemoteEvent")
            if not mainRemoteEvent then return false end
            
            -- Спавним пули в голове цели
            local success = pcall(function()
                mainRemoteEvent:FireServer(
                    "ShootGun",
                    tool.Handle,
                    target.Position,  -- Стреляем ИЗ головы цели
                    target.Position,  -- В голову цели
                    target,
                    Vector3.new(0, 0, 0)
                )
            end)
            
            return success
        end
        
        _G.MagicBulletsUtility = magicUtility
    end
    
    -- magic bullets framework
    do
        local MagicBulletsFramework = {
            enabled = false,
            connection = nil,
            shootDelay = 0.005,
            lastShotTime = 0
        }
        
        function MagicBulletsFramework.start()
            if MagicBulletsFramework.connection then
                return
            end
            
            MagicBulletsFramework.enabled = true
            
            MagicBulletsFramework.connection = RunService.Heartbeat:Connect(function()
                if not MagicBulletsFramework.enabled then
                    return
                end
                
                -- Проверяем задержку между выстрелами
                local now = tick()
                if now - MagicBulletsFramework.lastShotTime < MagicBulletsFramework.shootDelay then
                    return
                end
                
                local utility = _G.MagicBulletsUtility
                if not utility then
                    return
                end
                
                -- Получаем выбранную цель
                local target = utility:getSelectedTarget()
                if not target then
                    return
                end
                
                -- Выполняем выстрел
                local success = utility:performShoot(target)
                if success then
                    MagicBulletsFramework.lastShotTime = now
                end
            end)
        end
        
        function MagicBulletsFramework.stop()
            MagicBulletsFramework.enabled = false
            if MagicBulletsFramework.connection then
                MagicBulletsFramework.connection:Disconnect()
                MagicBulletsFramework.connection = nil
            end
        end
        
        _G.MagicBulletsFramework = MagicBulletsFramework
    end
    
    -- multi weapon utility
    do
        local multiWeaponUtility = {}
        
        local multiguns_state = {
            enabled = false,
            equipped_tools = {},
            character = nil,
            tool_added_conn = nil,
            tool_removed_conn = nil,
            char_added_conn = nil,
            heartbeat_conn = nil,
            character_spawn_time = 0,
            spawn_delay = 2 -- Задержка 2 секунды после респавна
        }
        
        -- Проверка полной загрузки оружия
        function multiWeaponUtility:isToolFullyLoaded(tool)
            if not tool or not tool:IsA("Tool") then
                return false
            end
            
            -- Проверяем основные компоненты
            local handle = tool:FindFirstChild("Handle")
            if not handle then
                return false
            end
            
            -- Проверяем наличие важных компонентов для оружия
            local hasAmmo = tool:FindFirstChild("Ammo") or tool:FindFirstChild("MaxAmmo") or tool:FindFirstChild("CurrentAmmo")
            local hasScript = tool:FindFirstChild("LocalScript") or tool:FindFirstChild("Script")
            
            -- Для полной загрузки нужны Handle и хотя бы один из компонентов
            return handle and (hasAmmo or hasScript)
        end
        
        -- Экипировка всех оружий
        function multiWeaponUtility:equipAllWeapons()
            if not multiguns_state.character or not multiguns_state.character.Parent then
                return
            end
            
            -- Проверяем задержку после респавна
            local now = tick()
            if now - multiguns_state.character_spawn_time < multiguns_state.spawn_delay then
                return -- Ждем полной загрузки после респавна
            end
            
            multiguns_state.equipped_tools = {}
            
            local backpack = LocalPlayer:FindFirstChild("Backpack")
            if backpack then
                for _, tool in ipairs(backpack:GetChildren()) do
                    if tool:IsA("Tool") and allowed_tools[tool.Name] and tool.Parent == backpack then
                        -- Проверяем полную загрузку оружия перед экипировкой
                        if self:isToolFullyLoaded(tool) then
                            pcall(function()
                                tool.Parent = multiguns_state.character
                            end)
                        end
                    end
                end
            end
            
            if multiguns_state.character then
                for _, tool in ipairs(multiguns_state.character:GetChildren()) do
                    if tool:IsA("Tool") and allowed_tools[tool.Name] and tool:FindFirstChild("Handle") then
                        table.insert(multiguns_state.equipped_tools, tool)
                    end
                end
            end
        end
        
        -- Получение экипированных оружий
        function multiWeaponUtility:getEquippedWeapons()
            return multiguns_state.equipped_tools
        end
        
        -- Обработка добавления персонажа
        function multiWeaponUtility:onCharacterAdded(new_char)
            if not new_char or not new_char.Parent then
                return
            end
            
            multiguns_state.character = new_char
            multiguns_state.character_spawn_time = tick() -- Записываем время респавна
            
            if multiguns_state.tool_added_conn then 
                pcall(function() multiguns_state.tool_added_conn:Disconnect() end)
            end
            if multiguns_state.tool_removed_conn then 
                pcall(function() multiguns_state.tool_removed_conn:Disconnect() end)
            end
            
            multiguns_state.tool_added_conn = new_char.ChildAdded:Connect(function(child)
                if child:IsA("Tool") and allowed_tools[child.Name] and child:FindFirstChild("Handle") then
                    pcall(function()
                        table.insert(multiguns_state.equipped_tools, child)
                    end)
                end
            end)
            
            multiguns_state.tool_removed_conn = new_char.ChildRemoved:Connect(function(child)
                if child:IsA("Tool") then
                    pcall(function()
                        for i, tool in ipairs(multiguns_state.equipped_tools) do
                            if tool == child then
                                table.remove(multiguns_state.equipped_tools, i)
                                break
                            end
                        end
                    end)
                end
            end)
            
            if multiguns_state.enabled then
                pcall(function()
                    self:equipAllWeapons()
                end)
            end
        end
        
        function multiWeaponUtility:enable()
            multiguns_state.enabled = true
            multiguns_state.character = LocalPlayer.Character
            multiguns_state.last_equip_time = 0
            
            if multiguns_state.character then
                self:onCharacterAdded(multiguns_state.character)
            end
            
            -- Подключаемся к событию добавления персонажа
            if not multiguns_state.char_added_conn then
                multiguns_state.char_added_conn = LocalPlayer.CharacterAdded:Connect(function(new_char)
                    self:onCharacterAdded(new_char)
                end)
            end
            
            -- Циклическая экипировка оружий с задержкой
            multiguns_state.heartbeat_conn = RunService.Heartbeat:Connect(function()
                if not multiguns_state.enabled then return end
                if not multiguns_state.character or not multiguns_state.character.Parent then return end
                
                local now = tick()
                if now - (multiguns_state.last_equip_time or 0) >= 0.1 then -- Задержка 0.1 секунды
                    multiguns_state.last_equip_time = now
                    pcall(function()
                        self:equipAllWeapons()
                    end)
                end
            end)
        end
        
        function multiWeaponUtility:disable()
            multiguns_state.enabled = false
            
            if multiguns_state.heartbeat_conn then
                multiguns_state.heartbeat_conn:Disconnect()
                multiguns_state.heartbeat_conn = nil
            end
            
            if multiguns_state.tool_added_conn then
                multiguns_state.tool_added_conn:Disconnect()
                multiguns_state.tool_added_conn = nil
            end
            
            if multiguns_state.tool_removed_conn then
                multiguns_state.tool_removed_conn:Disconnect()
                multiguns_state.tool_removed_conn = nil
            end
            
            if multiguns_state.char_added_conn then
                multiguns_state.char_added_conn:Disconnect()
                multiguns_state.char_added_conn = nil
            end
            
            multiguns_state.equipped_tools = {}
        end
        
        _G.MultiWeaponUtility = multiWeaponUtility
    end
    
    -- Utility function to deep copy a table
    local function table_clone(orig)
        local orig_type = type(orig)
        local copy
        if orig_type == 'table' then
            copy = {}
            for orig_key, orig_value in next, orig, nil do
                copy[table_clone(orig_key)] = table_clone(orig_value)
            end
            setmetatable(copy, table_clone(getmetatable(orig)))
        else -- number, string, boolean, etc
            copy = orig
        end
        return copy
    end

    -- wallbang utility
    do
        local wallbangUtility = {}
        local wallbang_state = {
            enabled = false,
            handler = nil,
            module = nil,
            original_ignored = nil
        }
        
        function wallbangUtility:enable()
            if wallbang_state.enabled then return true end
            
            local success, err = pcall(function()
                -- Get MainModule from ReplicatedStorage
                local mainModule = game:GetService("ReplicatedStorage"):FindFirstChild("MainModule")
                if not mainModule then
                    error("MainModule not found in ReplicatedStorage")
                end
                
                -- Require the module
                local module = require(mainModule)
                if not module then
                    error("Failed to require MainModule")
                end
                
                -- Save original state
                wallbang_state.handler = mainModule
                wallbang_state.module = module
                wallbang_state.original_ignored = table_clone(module.Ignored or {})
                
                -- Set new Ignored configuration
                module.Ignored = {
                    workspace:WaitForChild("Vehicles"),
                    workspace:WaitForChild("MAP"),
                    workspace:WaitForChild("Ignored")
                }
                
                wallbang_state.enabled = true
                return true
            end)
            
            if not success then
                -- Clean up on error
                wallbangUtility:disable()
                warn("Failed to enable Wallbang:", err)
                return false, err
            end
            
            return true
        end
        
        function wallbangUtility:disable()
            if not wallbang_state.enabled then return true end
            
            local success, err = pcall(function()
                if wallbang_state.module and wallbang_state.original_ignored ~= nil then
                    wallbang_state.module.Ignored = table_clone(wallbang_state.original_ignored)
                end
                return true
            end)
            
            -- Always clean up state
            wallbang_state.enabled = false
            wallbang_state.module = nil
            wallbang_state.handler = nil
            wallbang_state.original_ignored = nil
            
            if not success then
                warn("Error disabling Wallbang:", err)
                return false, err
            end
            
            return true
        end
        
        function wallbangUtility:isEnabled()
            return wallbang_state.enabled == true
        end
        
        _G.WallbangUtility = wallbangUtility
    end
    
    -- silent aim prediction logic
    do
        local lastPositions, lastUpdateTimes = {}, {}
        
        local function predictPosition(player)
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return nil end
            local aimPart = player.Character.HumanoidRootPart
            local aimPartPos = aimPart.Position
            local playerId = player.UserId
            
            if not lastPositions[playerId] or not lastUpdateTimes[playerId] then
                lastPositions[playerId] = aimPartPos
                lastUpdateTimes[playerId] = tick()
                return aimPartPos
            end
            
            local currentTime = tick()
            local deltaTime = currentTime - lastUpdateTimes[playerId]
            local predictedPos
            local resolverType = _G.resolver_type
            
            if resolverType == "Velocity" then
                local velocity = aimPart.Velocity
                predictedPos = aimPartPos + Vector3.new(
                    velocity.X * _G.prediction_xz,
                    velocity.Y * _G.prediction_y,
                    velocity.Z * _G.prediction_xz
                )
            elseif resolverType == "Move direction" then
                predictedPos = aimPartPos + (player.Character.Humanoid.MoveDirection * (_G.prediction_xz * 10))
            elseif resolverType == "Calculate Cframe" then
                local distance = (aimPartPos - lastPositions[playerId]).Magnitude
                if distance < 0.001 then
                    predictedPos = aimPartPos
                else
                    local predictedDistance = (distance / deltaTime) * (0.1 * (_G.prediction_xz * 10))
                    predictedPos = aimPartPos + (aimPartPos - lastPositions[playerId]).Unit * predictedDistance
                    local yChange = (aimPartPos.Y - lastPositions[playerId].Y) / deltaTime * (0.1 * _G.prediction_y)
                    predictedPos = predictedPos + Vector3.new(0, yChange, 0)
                end
            end
            
            lastPositions[playerId] = aimPartPos
            lastUpdateTimes[playerId] = currentTime
            return predictedPos
        end
        
        _G.predictPosition = predictPosition
    end
    
    -- aimbot tracer implementation
    do
        -- Создаем drawing объекты для трейсера (outline + основная линия)
        local Drawing = Drawing or {}
        
        -- Outline линия (обводка)
        _G.aimbot_tracer_outline = Drawing.new("Line")
        _G.aimbot_tracer_outline.Visible = false
        _G.aimbot_tracer_outline.Color = Color3.new(0, 0, 0) -- черный по умолчанию
        _G.aimbot_tracer_outline.Thickness = 3.5
        _G.aimbot_tracer_outline.Transparency = 1
        _G.aimbot_tracer_outline.ZIndex = 0
        
        -- Основная линия
        _G.aimbot_tracer = Drawing.new("Line")
        _G.aimbot_tracer.Visible = false
        _G.aimbot_tracer.Color = Color3.new(1, 1, 1) -- белый по умолчанию
        _G.aimbot_tracer.Thickness = 1.5
        _G.aimbot_tracer.Transparency = 1
        _G.aimbot_tracer.ZIndex = 1
        
        -- Функция для получения muzzle позиции
        local function getToolMuzzle()
            local character = LocalPlayer.Character
            if not character then return nil end
            local tool = character:FindFirstChildOfClass("Tool")
            if not tool or not tool:FindFirstChild("Handle") then return nil end
            
            local handle = tool.Handle
            -- Ищем Muzzle attachment внутри Handle
            local muzzle = handle:FindFirstChild("Muzzle")
            if muzzle then
                return muzzle.WorldPosition
            end
            
            -- Если Muzzle не найден, возвращаем позицию Handle как fallback
            return handle.Position
        end
        
        -- Функция для обновления трейсера
        local function updateTracer()
            -- Двойная проверка тоглов для безопасности
            if not _G.show_aimbot or not _G.silent_aim_enabled then
                if _G.aimbot_tracer then
                    _G.aimbot_tracer.Visible = false
                end
                if _G.aimbot_tracer_outline then
                    _G.aimbot_tracer_outline.Visible = false
                end
                return
            end
            
            local targetPlayer = _G.targeting_state.current
            if not targetPlayer or not targetPlayer.Character then
                _G.aimbot_tracer.Visible = false
                _G.aimbot_tracer_outline.Visible = false
                return
            end
            
            local muzzlePos = getToolMuzzle()
            if not muzzlePos then
                _G.aimbot_tracer.Visible = false
                _G.aimbot_tracer_outline.Visible = false
                return
            end
            
            -- Используем глобальную функцию предсказания
            local aimPos = _G.predictPosition(targetPlayer)
            if not aimPos then
                _G.aimbot_tracer.Visible = false
                _G.aimbot_tracer_outline.Visible = false
                return
            end
            
            -- Конвертируем 3D позиции в 2D экранные координаты
            local camera = workspace.CurrentCamera
            local muzzleScreenPos, muzzleOnScreen = camera:WorldToViewportPoint(muzzlePos)
            local aimScreenPos, aimOnScreen = camera:WorldToViewportPoint(aimPos)
            
            if muzzleOnScreen and aimOnScreen then
                local fromPos = Vector2.new(muzzleScreenPos.X, muzzleScreenPos.Y)
                local toPos = Vector2.new(aimScreenPos.X, aimScreenPos.Y)
                
                -- Обновляем outline линию
                _G.aimbot_tracer_outline.From = fromPos
                _G.aimbot_tracer_outline.To = toPos
                _G.aimbot_tracer_outline.Color = _G.aimbot_outline_color
                _G.aimbot_tracer_outline.Visible = true
                
                -- Обновляем основную линию
                _G.aimbot_tracer.From = fromPos
                _G.aimbot_tracer.To = toPos
                _G.aimbot_tracer.Color = _G.aimbot_color
                _G.aimbot_tracer.Visible = true
            else
                _G.aimbot_tracer.Visible = false
                _G.aimbot_tracer_outline.Visible = false
            end
        end
        
        -- Подключаем обновление трейсера к Heartbeat
        _G.tracer_update_connection = RunService.Heartbeat:Connect(function()
            if _G.show_aimbot and _G.silent_aim_enabled then
                updateTracer()
            else
                if _G.aimbot_tracer then
                    _G.aimbot_tracer.Visible = false
                end
                if _G.aimbot_tracer_outline then
                    _G.aimbot_tracer_outline.Visible = false
                end
            end
        end)
    end
    
    -- hitbox expander utility
    do
        local hitboxExpanderUtility = {}
        local HitboxExpandedPlayers = {}
        
        function hitboxExpanderUtility:ExpandHitbox(player, size, visible, color)
            if not player.Character then return end
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            if not HitboxExpandedPlayers[player] then
                HitboxExpandedPlayers[player] = {
                    OriginalSize = hrp.Size,
                    OriginalTransparency = hrp.Transparency,
                    OriginalCanCollide = hrp.CanCollide,
                    SelectionBox = nil
                }
            end

            local data = HitboxExpandedPlayers[player]
            hrp.Size = Vector3.new(size, size, size)
            hrp.CanCollide = false

            if visible then
                hrp.Transparency = 0.9 -- highly transparent so visible but not fully blocking
                if not data.SelectionBox then
                    local selBox = Instance.new("SelectionBox")
                    selBox.Adornee = hrp
                    selBox.Color3 = color or Color3.new(1, 0, 0)
                    selBox.LineThickness = 0.05
                    selBox.SurfaceTransparency = 0.7
                    selBox.Parent = hrp
                    data.SelectionBox = selBox
                else
                    data.SelectionBox.Color3 = color or Color3.new(1, 0, 0)
                end
            else
                hrp.Transparency = 1 -- fully invisible
                if data.SelectionBox then
                    data.SelectionBox:Destroy()
                    data.SelectionBox = nil
                end
            end
        end

        function hitboxExpanderUtility:ResetHitbox(player)
            if not player.Character then return end
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            local data = HitboxExpandedPlayers[player]
            if hrp and data then
                hrp.Size = data.OriginalSize
                hrp.Transparency = data.OriginalTransparency
                hrp.CanCollide = data.OriginalCanCollide
                if data.SelectionBox then
                    data.SelectionBox:Destroy()
                    data.SelectionBox = nil
                end
                HitboxExpandedPlayers[player] = nil
            end
        end

        function hitboxExpanderUtility:UpdateHitboxes()
            local enabled = hitboxExpanderMod.enabled
            local size = hitboxExpanderMod.size
            local visible = hitboxExpanderMod.visible
            local color = hitboxExpanderMod.color

            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    if enabled and not (_G.skip_ko and _G.IsKO and _G.IsKO(player)) then
                        hitboxExpanderUtility:ExpandHitbox(player, size, visible, color)
                    else
                        hitboxExpanderUtility:ResetHitbox(player)
                    end
                end
            end
        end

        function hitboxExpanderUtility:enable()
            hitboxExpanderMod.enabled = true
        end

        function hitboxExpanderUtility:disable()
            hitboxExpanderMod.enabled = false
            -- Сбрасываем все хитбоксы при отключении
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer then
                    hitboxExpanderUtility:ResetHitbox(player)
                end
            end
        end

        _G.HitboxExpanderUtility = hitboxExpanderUtility
    end
    
    -- infinity range utility
    do
        local infinityRangeUtility = {}
        local originalValues = {}
        local connection = nil
        
        local function findRangeValues(weapon)
            local rangeValues = {}
            
            -- Прямой поиск в оружии
            local range = weapon:FindFirstChild("Range") or 
                         weapon:FindFirstChild("MaxRange") or 
                         weapon:FindFirstChild("Distance") or
                         weapon:FindFirstChild("MaxDistance") or
                         weapon:FindFirstChild("Reach")
            if range then
                table.insert(rangeValues, range)
            end
            
            -- Поиск в Configuration/Settings
            local config = weapon:FindFirstChild("Configuration") or 
                          weapon:FindFirstChild("Settings") or
                          weapon:FindFirstChild("Config") or
                          weapon:FindFirstChild("Stats")
            if config then
                local configRange = config:FindFirstChild("Range") or 
                                   config:FindFirstChild("MaxRange") or
                                   config:FindFirstChild("Distance") or
                                   config:FindFirstChild("MaxDistance") or
                                   config:FindFirstChild("Reach") or
                                   config:FindFirstChild("FireRange")
                if configRange then
                    table.insert(rangeValues, configRange)
                end
            end
            
            -- Поиск в Handle
            local handle = weapon:FindFirstChild("Handle")
            if handle then
                local handleRange = handle:FindFirstChild("Range") or 
                                   handle:FindFirstChild("MaxRange") or
                                   handle:FindFirstChild("Distance")
                if handleRange then
                    table.insert(rangeValues, handleRange)
                end
                
                -- Поиск в Handle/Configuration
                local handleConfig = handle:FindFirstChild("Configuration") or 
                                    handle:FindFirstChild("Settings")
                if handleConfig then
                    local hcRange = handleConfig:FindFirstChild("Range") or 
                                   handleConfig:FindFirstChild("MaxRange") or
                                   handleConfig:FindFirstChild("Distance")
                    if hcRange then
                        table.insert(rangeValues, hcRange)
                    end
                end
            end
            
            -- Поиск в GunScript или аналогичных скриптах
            local gunScript = weapon:FindFirstChild("GunScript") or 
                             weapon:FindFirstChild("WeaponScript") or
                             weapon:FindFirstChild("Script")
            if gunScript then
                local scriptRange = gunScript:FindFirstChild("Range") or 
                                   gunScript:FindFirstChild("MaxRange")
                if scriptRange then
                    table.insert(rangeValues, scriptRange)
                end
            end
            
            return rangeValues
        end
        
        local function updateRange(weapon)
            local rangeValues = findRangeValues(weapon)
            
            for _, rangeValue in ipairs(rangeValues) do
                if rangeValue:IsA("NumberValue") or rangeValue:IsA("IntValue") then
                    local key = tostring(weapon) .. "_" .. tostring(rangeValue)
                    if infinityRangeMod.enabled then
                        if not originalValues[key] then
                            originalValues[key] = rangeValue.Value
                        end
                        rangeValue.Value = 999999999999999999
                    else
                        if originalValues[key] then
                            rangeValue.Value = originalValues[key]
                        end
                    end
                end
            end
        end
        
        local function isAllowedWeapon(weaponName)
            return allowed_tools[weaponName] == true
        end
        
        function infinityRangeUtility:enable()
            infinityRangeMod.enabled = true
            
            if not connection then
                connection = RunService.Heartbeat:Connect(function()
                    if not infinityRangeMod.enabled then
                        return
                    end
                    
                    -- Ищем оружие в руках
                    local character = LocalPlayer.Character
                    if character then
                        local tool = character:FindFirstChildOfClass("Tool")
                        if tool and isAllowedWeapon(tool.Name) then
                            pcall(function()
                                updateRange(tool)
                            end)
                        end
                    end
                    
                    -- Ищем оружие в рюкзаке
                    local backpack = LocalPlayer:FindFirstChild("Backpack")
                    if backpack then
                        for _, tool in pairs(backpack:GetChildren()) do
                            if tool:IsA("Tool") and isAllowedWeapon(tool.Name) then
                                pcall(function()
                                    updateRange(tool)
                                end)
                            end
                        end
                    end
                    
                    -- Ищем оружие в workspace.Players
                    local playersFolder = workspace:FindFirstChild("Players")
                    if playersFolder then
                        local playerFolder = playersFolder:FindFirstChild(LocalPlayer.Name)
                        if playerFolder then
                            for _, child in pairs(playerFolder:GetChildren()) do
                                if isAllowedWeapon(child.Name) then
                                    pcall(function()
                                        updateRange(child)
                                    end)
                                end
                            end
                        end
                    end
                end)
            end
        end
        
        function infinityRangeUtility:disable()
            infinityRangeMod.enabled = false
            
            -- Восстанавливаем все оригинальные значения
            local character = LocalPlayer.Character
            if character then
                local tool = character:FindFirstChildOfClass("Tool")
                if tool then
                    pcall(function()
                        updateRange(tool)
                    end)
                end
            end
            
            local backpack = LocalPlayer:FindFirstChild("Backpack")
            if backpack then
                for _, tool in pairs(backpack:GetChildren()) do
                    if tool:IsA("Tool") then
                        pcall(function()
                            updateRange(tool)
                        end)
                    end
                end
            end
            
            local playersFolder = workspace:FindFirstChild("Players")
            if playersFolder then
                local playerFolder = playersFolder:FindFirstChild(LocalPlayer.Name)
                if playerFolder then
                    for _, child in pairs(playerFolder:GetChildren()) do
                        pcall(function()
                            updateRange(child)
                        end)
                    end
                end
            end
            
            if connection then
                connection:Disconnect()
                connection = nil
            end
            
            -- Очищаем сохраненные значения
            originalValues = {}
        end
        
        _G.InfinityRangeUtility = infinityRangeUtility
    end
    
    -- auto reload utility
    do
        local autoReloadUtility = {}
        local connection = nil
        local lastReloadTime = 0
        local mainModule = nil
        
        function autoReloadUtility:enable()
            if connection then
                return
            end
            
            -- Получаем MainModule
            local replicatedStorage = game:GetService("ReplicatedStorage")
            local handler = replicatedStorage:FindFirstChild("MainModule")
            if not handler then
                return
            end
            
            local success, module = pcall(function()
                return require(handler)
            end)
            
            if not success or not module then
                return
            end
            
            mainModule = module
            autoReloadMod.enabled = true
            
            connection = RunService.Heartbeat:Connect(function()
                if not autoReloadMod.enabled then
                    return
                end
                
                -- Проверяем задержку после последней перезарядки
                local now = tick()
                if now - lastReloadTime < autoReloadMod.reloadDelay then
                    return
                end
                
                local character = LocalPlayer.Character
                if not character then
                    return
                end
                
                -- Используем логику с MainModule.GunHold
                local gun = mainModule.GunHold(character)
                if not gun or not gun[1] then
                    return
                end
                
                local tool = gun[1]
                local ammo = tool:FindFirstChild("Ammo")
                if not ammo or ammo.Value > 0 then
                    return
                end
                
                -- Перезаряжаем оружие через MainRemoteEvent
                local replicatedStorage = game:GetService("ReplicatedStorage")
                local mainRemotes = replicatedStorage:FindFirstChild("MainRemotes")
                if mainRemotes then
                    local mainRemoteEvent = mainRemotes:FindFirstChild("MainRemoteEvent")
                    if mainRemoteEvent then
                        mainRemoteEvent:FireServer("Reload", tool)
                        lastReloadTime = now
                    end
                end
            end)
        end
        
        function autoReloadUtility:disable()
            autoReloadMod.enabled = false
            
            if connection then
                connection:Disconnect()
                connection = nil
            end
            
            mainModule = nil
        end
        
        _G.AutoReloadUtility = autoReloadUtility
    end
    
    -- targeting groupbox
    do
        local TargetingGroup = Tabs['Rage']:AddLeftGroupbox('Targeting')
        
        TargetingGroup:AddLabel('select'):AddKeyPicker('TargetKey', {
            Default = 'Q',
            NoUI = false,
            Text = 'Target Key',
            Callback = function()
                local framework = _G.targeting_framework
                if framework then
                    -- Проверяем, есть ли уже цель
                    if _G.targeting_state.current then
                        -- Если есть цель, сбрасываем её
                        _G.targeting_state.current = nil
                        Library:Notify('Ragebot set to none', 2)
                    else
                        -- Если нет цели, ищем новую
                        local target = framework:GetClosestTarget()
                        if target then
                            framework:SetTarget(target)
                        else
                            Library:Notify('Notargetsfound', 2)
                        end
                    end
                end
            end
        })
        
        TargetingGroup:AddToggle('SilentAim', {
            Text = 'SilentAim',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                _G.silent_aim_enabled = value
                if value then
                    Library:Notify('on', 2)
                else
                    Library:Notify('off', 2)
                end
            end
        })
        
        -- Создаем dependency box для настроек SilentAim
        local SilentAimDepbox = TargetingGroup:AddDependencyBox()
        
        SilentAimDepbox:AddInput('PredictionXZ', {
            Default = '0.1',
            Numeric = true,
            Finished = false,
            Text = 'Prediction XZ',
            Tooltip = '>_<',
            Callback = function(value)
                _G.prediction_xz = tonumber(value) or 0.1
            end
        })
        
        SilentAimDepbox:AddInput('PredictionY', {
            Default = '0.1',
            Numeric = true,
            Finished = false,
            Text = 'Prediction Y',
            Tooltip = '>_<',
            Callback = function(value)
                _G.prediction_y = tonumber(value) or 0.1
            end
        })
        
        SilentAimDepbox:AddDropdown('ResolverType', {
            Values = {'Velocity', 'Move direction', 'Calculate Cframe'},
            Default = 1,
            Multi = false,
            Text = 'Resolver Type',
            Tooltip = '>_<',
            Callback = function(value)
                _G.resolver_type = value
            end
        })
        
        SilentAimDepbox:AddToggle('ShowAimbot', {
            Text = 'Show Aimbot',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                _G.show_aimbot = value
                -- Немедленно скрываем трейсер при отключении
                if not value then
                    if _G.aimbot_tracer then
                        _G.aimbot_tracer.Visible = false
                    end
                    if _G.aimbot_tracer_outline then
                        _G.aimbot_tracer_outline.Visible = false
                    end
                end
            end
        }):AddColorPicker('AimbotColor', {
            Default = Color3.new(1, 1, 1),
            Title = 'Aimbot Tracer Color',
            Callback = function(value)
                _G.aimbot_color = value
                if _G.aimbot_tracer then
                    _G.aimbot_tracer.Color = value
                end
            end
        }):AddColorPicker('AimbotOutlineColor', {
            Default = Color3.new(0, 0, 0),
            Title = 'Aimbot Outline Color',
            Callback = function(value)
                _G.aimbot_outline_color = value
                if _G.aimbot_tracer_outline then
                    _G.aimbot_tracer_outline.Color = value
                end
            end
        })
        
        -- Настраиваем зависимости
        SilentAimDepbox:SetupDependencies({
            { Toggles.SilentAim, true }
        })
        
        TargetingGroup:AddToggle('ForceHit', {
            Text = 'ForceHit',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                _G.forcehit_enabled = value
                if value then
                    Library:Notify('on', 2)
                else
                    Library:Notify('off', 2)
                end
            end
        })
        
        TargetingGroup:AddToggle('MagicBullets', {
            Text = 'Magic Bullets',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                _G.magic_bullets_enabled = value
                if value then
                    if _G.MagicBulletsFramework then
                        _G.MagicBulletsFramework.start()
                    end
                    Library:Notify('on', 2)
                else
                    if _G.MagicBulletsFramework then
                        _G.MagicBulletsFramework.stop()
                    end
                    Library:Notify('off', 2)
                end
            end
        })
        
        -- Создаем dependency box для настроек Magic Bullets
        local MagicBulletsDepbox = TargetingGroup:AddDependencyBox()
        
        MagicBulletsDepbox:AddDropdown('MagicBulletsChecks', {
            Values = {'Forcefield', 'K.O', 'Grabbed'},
            Default = {'Forcefield', 'K.O', 'Grabbed'},
            Multi = true,
            Text = 'Checks',
            Tooltip = '>_<',
            Callback = function(value)
                _G.magic_bullets_checks = value
            end
        })
        
        MagicBulletsDepbox:AddDropdown('MagicBulletsMode', {
            Values = {'Target', 'Killaura'},
            Default = 1,
            Multi = false,
            Text = 'Mode',
            Tooltip = '>_<',
            Callback = function(value)
                _G.magic_bullets_mode = value
            end
        })
        
        -- Настраиваем зависимости
        MagicBulletsDepbox:SetupDependencies({
            { Toggles.MagicBullets, true }
        })
        
        TargetingGroup:AddToggle('MultiWeapon', {
            Text = 'Multi Weapon',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                _G.multi_weapon_enabled = value
                if value then
                    if _G.MultiWeaponUtility then
                        _G.MultiWeaponUtility:enable()
                    end
                    Library:Notify('on', 2)
                else
                    if _G.MultiWeaponUtility then
                        _G.MultiWeaponUtility:disable()
                    end
                    Library:Notify('off', 2)
                end
            end
        })
        
        TargetingGroup:AddToggle('Wallbang', {
            Text = 'Wallbang',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                _G.wallbang_enabled = value
                if value then
                    if _G.WallbangUtility then
                        local success = _G.WallbangUtility:enable()
                        if success then
                            Library:Notify('on', 2)
                        else
                            Library:Notify('failed to enable', 3)
                            -- Сбрасываем тогл если не удалось включить
                            Toggles.Wallbang:SetValue(false)
                            _G.wallbang_enabled = false
                        end
                    end
                else
                    if _G.WallbangUtility then
                        _G.WallbangUtility:disable()
                    end
                    Library:Notify('off', 2)
                end
            end
        })
        
        TargetingGroup:AddToggle('NoSpread', {
            Text = 'NoSpread',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                _G.nospread_enabled = value
                spreadMod.enabled = value
                if value then
                    if _G.NoSpreadUtility then
                        _G.NoSpreadUtility:enable()
                    end
                    Library:Notify('on', 2)
                else
                    if _G.NoSpreadUtility then
                        _G.NoSpreadUtility:disable()
                    end
                    Library:Notify('off', 2)
                end
            end
        })
        
        -- Создаем dependency box для настроек NoSpread
        local NoSpreadDepbox = TargetingGroup:AddDependencyBox()
        
        NoSpreadDepbox:AddSlider('SpreadAmount', {
            Text = 'Spread Amount',
            Default = 100,
            Min = 0,
            Max = 100,
            Rounding = 1,
            Compact = false,
            Tooltip = '>_<',
            Callback = function(value)
                spreadMod.amount = value
                -- Обновляем все маркеры оружий с новым значением
                if _G.NoSpreadUtility then
                    _G.NoSpreadUtility:markAllWeapons()
                end
            end
        })
        
        -- Настраиваем зависимости
        NoSpreadDepbox:SetupDependencies({
            { Toggles.NoSpread, true }
        })
        
        TargetingGroup:AddToggle('RapidFire', {
            Text = 'RapidFire',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                _G.rapidfire_enabled = value
                rapidFireMod.enabled = value
                if value then
                    if _G.RapidFireUtility then
                        _G.RapidFireUtility:enable()
                    end
                    Library:Notify('on', 2)
                else
                    if _G.RapidFireUtility then
                        _G.RapidFireUtility:disable()
                    end
                    Library:Notify('off', 2)
                end
            end
        })
        
        
        
        -- Инициализируем настройки SilentAim, ForceHit, Magic Bullets, Multi Weapon, Wallbang, NoSpread, RapidFire и ExpandHitbox
        _G.silent_aim_enabled = false
        _G.forcehit_enabled = false
        _G.magic_bullets_enabled = false
        _G.magic_bullets_mode = 'Target'
        _G.magic_bullets_checks = {['Forcefield'] = true, ['K.O'] = true, ['Grabbed'] = true}
        _G.multi_weapon_enabled = false
        _G.wallbang_enabled = false
        _G.nospread_enabled = false
        _G.rapidfire_enabled = false
        _G.hitbox_expander_enabled = false
        _G.prediction_xz = 0.1
        _G.prediction_y = 0.1
        _G.resolver_type = 'Velocity'
        _G.show_aimbot = false
        _G.aimbot_color = Color3.new(1, 1, 1) -- белый по умолчанию
        _G.aimbot_outline_color = Color3.new(0, 0, 0) -- черный по умолчанию
        
        -- Auto update только при включенных функциях
        _G.target_update_connection = RunService.Heartbeat:Connect(function()
            -- Обновляем таргетинг только если включен SilentAim, ForceHit или Magic Bullets
            if (_G.silent_aim_enabled or _G.forcehit_enabled or _G.magic_bullets_enabled) and _G.targeting_framework then
                _G.targeting_framework:UpdateTarget()
            end
            -- Обновляем ForceHit цель только если ForceHit включен
            if _G.forcehit_enabled and _G.updateForceHitTarget then
                _G.updateForceHitTarget()
            end
            -- Обновляем хитбоксы только если ExpandHitbox включен
            if hitboxExpanderMod.enabled and _G.HitboxExpanderUtility then
                _G.HitboxExpanderUtility:UpdateHitboxes()
            end
        end)
    end
    
    -- other groupbox
    do
        local OtherGroup = Tabs['Rage']:AddRightGroupbox('Other')
        
        OtherGroup:AddToggle('ExpandHitbox', {
            Text = 'ExpandHitbox',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                hitboxExpanderMod.enabled = value
                if value then
                    if _G.HitboxExpanderUtility then
                        _G.HitboxExpanderUtility:enable()
                    end
                    Library:Notify('on', 2)
                else
                    if _G.HitboxExpanderUtility then
                        _G.HitboxExpanderUtility:disable()
                    end
                    Library:Notify('off', 2)
                end
            end
        })
        
        -- Создаем dependency box для настроек ExpandHitbox
        local ExpandHitboxDepbox = OtherGroup:AddDependencyBox()
        
        ExpandHitboxDepbox:AddSlider('HitboxSize', {
            Text = 'Hitbox Size',
            Default = 20,
            Min = 5,
            Max = 50,
            Rounding = 1,
            Compact = false,
            Tooltip = '>_<',
            Callback = function(value)
                hitboxExpanderMod.size = value
            end
        })
        
        ExpandHitboxDepbox:AddToggle('HitboxVisible', {
            Text = 'Visualise',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                hitboxExpanderMod.visible = value
            end
        }):AddColorPicker('HitboxColor', {
            Default = Color3.new(1, 0, 0),
            Title = 'Hitbox Color',
            Callback = function(value)
                hitboxExpanderMod.color = value
            end
        })
        
        -- Настраиваем зависимости
        ExpandHitboxDepbox:SetupDependencies({
            { Toggles.ExpandHitbox, true }
        })
        
        OtherGroup:AddToggle('InfinityRange', {
            Text = 'Infinity Range',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                infinityRangeMod.enabled = value
                if value then
                    if _G.InfinityRangeUtility then
                        _G.InfinityRangeUtility:enable()
                    end
                    Library:Notify('on', 2)
                else
                    if _G.InfinityRangeUtility then
                        _G.InfinityRangeUtility:disable()
                    end
                    Library:Notify('off', 2)
                end
            end
        })
        
        OtherGroup:AddToggle('AutoReload', {
            Text = 'Auto Reload',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                autoReloadMod.enabled = value
                if value then
                    if _G.AutoReloadUtility then
                        _G.AutoReloadUtility:enable()
                    end
                    Library:Notify('on', 2)
                else
                    if _G.AutoReloadUtility then
                        _G.AutoReloadUtility:disable()
                    end
                    Library:Notify('off', 2)
                end
            end
        })
    end
    
    -- skips groupbox
    do
        local SkipsGroup = Tabs['Rage']:AddRightGroupbox('Skips')
        
        SkipsGroup:AddToggle('SkipKO', {
            Text = 'K.O',
            Default = true,
            Tooltip = '>_<',
            Callback = function(value)
                _G.skip_ko = value
            end
        })
        
        -- Инициализируем настройку
        _G.skip_ko = true
    end
end
