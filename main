-- variables
local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local game, workspace = game, workspace
local Vector3, Vector2, CFrame, Color3 = Vector3, Vector2, CFrame, Color3
local Enum = Enum
local math, tick, pairs, pcall, tostring, tonumber, ipairs, table = math, tick, pairs, pcall, tostring, tonumber, ipairs, table
local getrawmetatable, setreadonly, checkcaller, hookmetamethod, newcclosure, getnamecallmethod = getrawmetatable, setreadonly, checkcaller, hookmetamethod, newcclosure, getnamecallmethod
local loadstring, setclipboard = loadstring, setclipboard
local TeleportService, HttpService, Players, RunService = game:GetService("TeleportService"), game:GetService("HttpService"), game:GetService("Players"), game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- multi weapon variables
local allowed_tools = {
    ["[AUG]"] = true,
    ["[Rifle]"] = true,
    ["[LMG]"] = true,
    ["[P90]"] = true,
    ["[Flintlock]"] = true,
    ["[Revolver]"] = true,
    ["[Double-Barrel SG]"] = true,
    ["[AK47]"] = true,
    ["[TacticalShotgun]"] = true,
}

-- forcehit variables
local forceHitTarget = {
    enabled = false,
    position = Vector3.new(0, 0, 0),
    part = nil
}

local Hooks = {}

-- ac bypass
loadstring(game:HttpGet("https://pastebin.com/raw/gimbTwW1"))()

-- silent aim hook (separate from forcehit)
do
    local Mouse = LocalPlayer:GetMouse()
    local MetaTable = getrawmetatable(game)
    local OldIndex = MetaTable.__index
    setreadonly(MetaTable, false)
    
    MetaTable.__index = function(self, key)
        if not checkcaller() and self == Mouse and _G.silent_aim_enabled then
            if key == "Hit" or key == "Target" then
                local targetPlayer = _G.targeting_state.current
                if targetPlayer and targetPlayer.Character then
                    local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if targetPart then
                        local finalPos = targetPart.Position
                        if _G.predictPosition then
                            local predictedPos = _G.predictPosition(targetPlayer)
                            if predictedPos then
                                finalPos = predictedPos
                                local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                                if humanoid then
                                    if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
                                        finalPos = finalPos + Vector3.new(0, 2, 0)
                                    elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                                        finalPos = finalPos + Vector3.new(0, -1, 0)
                                    end
                                end
                            end
                        end
                        return key == "Hit" and CFrame.new(finalPos) or targetPart
                    end
                end
            end
        end
        return OldIndex(self, key)
    end
    setreadonly(MetaTable, true)
end

-- forcehit hook (separate from silent aim)
do
    Hooks.Remote = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        local args = { ... }
        local method = getnamecallmethod():lower()

        if forceHitTarget.enabled and forceHitTarget.position and forceHitTarget.part and 
           method == 'fireserver' and self.Name == 'MainRemoteEvent' and args[1] == 'ShootGun' then
            args[3] = forceHitTarget.position
            args[5] = forceHitTarget.part
            args[6] = Vector3.new(0, 0, -1)
            return Hooks.Remote(self, unpack(args))
        end

        return Hooks.Remote(self, ...)
    end))
end

-- library initialization
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

-- window creation
local Window = Library:CreateWindow({
    Title = 'Clientsidedhook.pub',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

-- tabs
local Tabs = {
    ['Rage'] = Window:AddTab('Rage'),
    ['UI Settings'] = Window:AddTab('Settings'),
    
}

do -- ui settings configuration
    -- ui settings tab
    do
        local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
        
        MenuGroup:AddButton('Unload', function() 
            Library:Unload() 
        end)
        
        MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { 
            Default = 'End', 
            NoUI = true, 
            Text = 'Menu keybind' 
        })
        
        Library.ToggleKeybind = Options.MenuKeybind
        
        -- managers setup
        ThemeManager:SetLibrary(Library)
        SaveManager:SetLibrary(Library)
        SaveManager:IgnoreThemeSettings()
        SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
        
        -- folders
        ThemeManager:SetFolder('MyScriptHub')
        SaveManager:SetFolder('MyScriptHub/specific-game')
        
        -- build sections
        SaveManager:BuildConfigSection(Tabs['UI Settings'])
        ThemeManager:ApplyToTab(Tabs['UI Settings'])
        
        -- autoload
        SaveManager:LoadAutoloadConfig()
    end

    -- server groupbox
    do
        local ServerGroup = Tabs['UI Settings']:AddRightGroupbox('Server')
        
        ServerGroup:AddButton({
            Text = 'Copy GameID',
            Func = function()
                setclipboard(tostring(game.GameId))
                Library:Notify('GameID copied to clipboard', 2)
            end,
            Tooltip = '>_<'
        })
        
        ServerGroup:AddButton({
            Text = 'Copy JobID', 
            Func = function()
                setclipboard(game.JobId)
                Library:Notify('JobID copied to clipboard', 2)
            end,
            Tooltip = '>_<'
        })
        
        ServerGroup:AddButton({
            Text = 'Copy Join Script',
            Func = function()
                local joinScript = 'game:GetService("TeleportService"):TeleportToPlaceInstance(' .. 
                                  game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)'
                setclipboard(joinScript)
                Library:Notify('Join script copied to clipboard', 2)
            end,
            Tooltip = '>_<'
        })
        
        ServerGroup:AddButton({
            Text = 'Rejoin Game',
            Func = function()
                TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
            end,
            Tooltip = '>_<'
        })
        
        ServerGroup:AddButton({
            Text = 'Join New Server',
            Func = function()
                local success, serverData = pcall(function()
                    return HttpService:JSONDecode(
                        game:HttpGetAsync(
                            "https://games.roblox.com/v1/games/" .. 
                            game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
                        )
                    )
                end)
                
                if success and serverData and serverData.data and #serverData.data > 0 then
                    local randomServer = serverData.data[math.random(1, #serverData.data)]
                    TeleportService:TeleportToPlaceInstance(game.PlaceId, randomServer.id)
                else
                    Library:Notify('nope', 3)
                end
            end,
            Tooltip = '>_<'
        })
    end

    -- hud groupbox
    do
        local HUDGroup = Tabs['UI Settings']:AddRightGroupbox('HUD')
        
        HUDGroup:AddToggle('Watermark', {
            Text = 'Watermark',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                if value then
                    Library:SetWatermark('Clientsidedhook.pub | ' .. os.date('%d.%m.%Y'))
                end
                Library:SetWatermarkVisibility(value)
            end
        })
        
        HUDGroup:AddToggle('KeybindList', {
            Text = 'Keybind List',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                Library.KeybindFrame.Visible = value
            end
        })
    end
end

do -- rage tab configuration
    -- targeting framework
    do
        local targeting_state = {current = nil}
        pcall(function()
            _G.targeting_state = targeting_state
        end)
        
        local utility = {}
        
        function utility:ValidateClient(player)
            if not player then return false end
            local character = player.Character
            if not character then return false end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0 then return false end
            return humanoid.RootPart ~= nil
        end
        
        function utility:GetPreferredPart(character)
            return character and 
                (character:FindFirstChild("HumanoidRootPart") or 
                 character:FindFirstChild("Head") or 
                 character:FindFirstChild("UpperTorso") or
                 character:FindFirstChild("Torso")) or nil
        end
        
        function utility:ToScreen(position)
            local camera = workspace.CurrentCamera
            local screenPos, onScreen = camera:WorldToViewportPoint(position)
            return Vector2.new(screenPos.X, screenPos.Y), onScreen
        end
        
        function utility:GetMouseLocation()
            local UserInputService = game:GetService("UserInputService")
            return UserInputService:GetMouseLocation()
        end
        
        function utility:GetMouseDistance(screenPos)
            return (utility:GetMouseLocation() - screenPos).Magnitude
        end
        
        function utility:isPlayerKO(player)
            if not player or not player.Character then return false end
            
            -- Проверяем K.O статус через BodyEffects
            local success, isKO = pcall(function()
                local playerInWorkspace = workspace.Players:FindFirstChild(player.Name)
                if playerInWorkspace and playerInWorkspace:FindFirstChild("BodyEffects") then
                    local koEffect = playerInWorkspace.BodyEffects:FindFirstChild("K.O")
                    if koEffect and koEffect.value then
                        return koEffect.value == true
                    end
                end
                return false
            end)
            
            if success then
                return isKO
            end
            
            -- Fallback к проверке здоровья если BodyEffects недоступны
            local humanoid = player.Character:FindFirstChild("Humanoid")
            return humanoid and humanoid.Health <= 0
        end
        
        local framework = {}
        
        function framework:GetClosestTarget()
            local closest = nil
            local shortestDistance = math.huge
            local mousePos = utility:GetMouseLocation()
            
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and utility:ValidateClient(player) then
                    -- Проверяем, нужно ли пропускать цель с K.O статусом
                    if _G.skip_ko and utility:isPlayerKO(player) then
                        -- Пропускаем игрока с K.O статусом
                    else
                        local character = player.Character
                        local part = utility:GetPreferredPart(character)
                        if part then
                            local screenPos, onScreen = utility:ToScreen(part.Position)
                            if onScreen then
                                local distance = utility:GetMouseDistance(screenPos)
                                if distance < shortestDistance then
                                    shortestDistance = distance
                                    closest = player
                                end
                            end
                        end
                    end
                end
            end
            
            return closest
        end
        
        function framework:SetTarget(player)
            if utility:ValidateClient(player) then
                targeting_state.current = player
                local koStatus = utility:isPlayerKO(player)
                Library:Notify('ragetbot set to: ' .. player.Name .. ' | isKO: ' .. tostring(koStatus), 2)
                return true
            else
                targeting_state.current = nil
                Library:Notify('Invalid target', 2)
                return false
            end
        end
        
        function framework:GetCurrentTarget()
            if targeting_state.current and utility:ValidateClient(targeting_state.current) then
                return targeting_state.current
            else
                targeting_state.current = nil
                return nil
            end
        end
        
        function framework:UpdateTarget()
            local current = targeting_state.current
            if current and not utility:ValidateClient(current) then
                -- Цель умерла или недоступна, ищем новую
                local newTarget = framework:GetClosestTarget()
                if newTarget then
                    framework:SetTarget(newTarget)
                else
                    targeting_state.current = nil
                    Library:Notify('No valid targets', 2)
                end
            end
        end
        
        _G.targeting_framework = framework
    end
    
    -- forcehit functionality
    do
        local function updateForceHitTarget()
            -- Всегда сначала проверяем глобальный тогл
            if not _G.forcehit_enabled then
                forceHitTarget.enabled = false
                forceHitTarget.position = Vector3.new(0, 0, 0)
                forceHitTarget.part = nil
                return
            end
            
            local targetPlayer = _G.targeting_state.current
            if targetPlayer and targetPlayer.Character then
                local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                
                if targetPart then
                    forceHitTarget.enabled = true
                    forceHitTarget.position = targetPart.Position
                    forceHitTarget.part = targetPart
                else
                    forceHitTarget.enabled = false
                    forceHitTarget.position = Vector3.new(0, 0, 0)
                    forceHitTarget.part = nil
                end
            else
                forceHitTarget.enabled = false
                forceHitTarget.position = Vector3.new(0, 0, 0)
                forceHitTarget.part = nil
            end
        end
        
        _G.updateForceHitTarget = updateForceHitTarget
    end
    
    -- magic bullets utility
    do
        local magicUtility = {}
        
        function magicUtility:getSelectedTarget()
            local mode = _G.magic_bullets_mode or "Target"
            
            if mode == "Target" then
                -- Используем выбранную цель из системы таргетинга
                if not _G.targeting_state or not _G.targeting_state.current then
                    return nil
                end
                
                local targetPlayer = _G.targeting_state.current
                if not targetPlayer or not targetPlayer.Character then
                    return nil
                end
                
                local target_head = targetPlayer.Character:FindFirstChild("Head")
                return target_head
            elseif mode == "Killaura" then
                -- Находим ближайшую цель для killaura режима
                local framework = _G.targeting_framework
                if not framework then return nil end
                
                local closestTarget = framework:GetClosestTarget()
                if not closestTarget or not closestTarget.Character then
                    return nil
                end
                
                local target_head = closestTarget.Character:FindFirstChild("Head")
                return target_head
            end
            
            return nil
        end
        
        function magicUtility:performShoot(target)
            if not target then return false end
            
            -- Проверяем K.O статус цели перед выстрелом
            local targetPlayer = nil
            local mode = _G.magic_bullets_mode or "Target"
            
            if mode == "Target" then
                targetPlayer = _G.targeting_state.current
            elseif mode == "Killaura" then
                -- Находим игрока по target части
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character then
                        local head = player.Character:FindFirstChild("Head")
                        if head == target then
                            targetPlayer = player
                            break
                        end
                    end
                end
            end
            
            if targetPlayer and targetPlayer.Character then
                local checks = _G.magic_bullets_checks or {}
                
                -- Проверка K.O статуса (если включена)
                if checks['K.O'] then
                    local bodyEffects = targetPlayer.Character:FindFirstChild("BodyEffects")
                    if bodyEffects and bodyEffects:FindFirstChild("K.O") then
                        if bodyEffects["K.O"].Value then
                            return false -- Цель в K.O, не стреляем
                        end
                    end
                end
                
                -- Проверка Forcefield (если включена)
                if checks['Forcefield'] then
                    local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid:FindFirstChild("ForceField") then
                        return false -- У цели есть forcefield, не стреляем
                    end
                end
                
                -- Проверка Grabbed статуса (если включена)
                if checks['Grabbed'] then
                    local bodyEffects = targetPlayer.Character:FindFirstChild("BodyEffects")
                    if bodyEffects and bodyEffects:FindFirstChild("Grabbed") then
                        if bodyEffects["Grabbed"].Value then
                            return false -- Цель схвачена, не стреляем
                        end
                    end
                end
            end
            
            local character = LocalPlayer.Character
            if not character then return false end
            
            local tool = character:FindFirstChildOfClass("Tool")
            if not tool or not tool:FindFirstChild("Handle") then return false end
            
            -- Получаем MainRemoteEvent
            local replicatedStorage = game:GetService("ReplicatedStorage")
            local mainRemotes = replicatedStorage:FindFirstChild("MainRemotes")
            if not mainRemotes then return false end
            
            local mainRemoteEvent = mainRemotes:FindFirstChild("MainRemoteEvent")
            if not mainRemoteEvent then return false end
            
            -- Спавним пули в голове цели
            local success = pcall(function()
                mainRemoteEvent:FireServer(
                    "ShootGun",
                    tool.Handle,
                    target.Position,  -- Стреляем ИЗ головы цели
                    target.Position,  -- В голову цели
                    target,
                    Vector3.new(0, 0, 0)
                )
            end)
            
            return success
        end
        
        _G.MagicBulletsUtility = magicUtility
    end
    
    -- magic bullets framework
    do
        local MagicBulletsFramework = {
            enabled = false,
            connection = nil,
            shootDelay = 0.005,
            lastShotTime = 0
        }
        
        function MagicBulletsFramework.start()
            if MagicBulletsFramework.connection then
                return
            end
            
            MagicBulletsFramework.enabled = true
            
            MagicBulletsFramework.connection = RunService.Heartbeat:Connect(function()
                if not MagicBulletsFramework.enabled then
                    return
                end
                
                -- Проверяем задержку между выстрелами
                local now = tick()
                if now - MagicBulletsFramework.lastShotTime < MagicBulletsFramework.shootDelay then
                    return
                end
                
                local utility = _G.MagicBulletsUtility
                if not utility then
                    return
                end
                
                -- Получаем выбранную цель
                local target = utility:getSelectedTarget()
                if not target then
                    return
                end
                
                -- Выполняем выстрел
                local success = utility:performShoot(target)
                if success then
                    MagicBulletsFramework.lastShotTime = now
                end
            end)
        end
        
        function MagicBulletsFramework.stop()
            MagicBulletsFramework.enabled = false
            if MagicBulletsFramework.connection then
                MagicBulletsFramework.connection:Disconnect()
                MagicBulletsFramework.connection = nil
            end
        end
        
        _G.MagicBulletsFramework = MagicBulletsFramework
    end
    
    -- multi weapon utility
    do
        local multiWeaponUtility = {}
        
        local multiguns_state = {
            enabled = false,
            equipped_tools = {},
            character = nil,
            tool_added_conn = nil,
            tool_removed_conn = nil,
            char_added_conn = nil,
            heartbeat_conn = nil,
            character_spawn_time = 0,
            spawn_delay = 2 -- Задержка 2 секунды после респавна
        }
        
        -- Проверка полной загрузки оружия
        function multiWeaponUtility:isToolFullyLoaded(tool)
            if not tool or not tool:IsA("Tool") then
                return false
            end
            
            -- Проверяем основные компоненты
            local handle = tool:FindFirstChild("Handle")
            if not handle then
                return false
            end
            
            -- Проверяем наличие важных компонентов для оружия
            local hasAmmo = tool:FindFirstChild("Ammo") or tool:FindFirstChild("MaxAmmo") or tool:FindFirstChild("CurrentAmmo")
            local hasScript = tool:FindFirstChild("LocalScript") or tool:FindFirstChild("Script")
            
            -- Для полной загрузки нужны Handle и хотя бы один из компонентов
            return handle and (hasAmmo or hasScript)
        end
        
        -- Экипировка всех оружий
        function multiWeaponUtility:equipAllWeapons()
            if not multiguns_state.character or not multiguns_state.character.Parent then
                return
            end
            
            -- Проверяем задержку после респавна
            local now = tick()
            if now - multiguns_state.character_spawn_time < multiguns_state.spawn_delay then
                return -- Ждем полной загрузки после респавна
            end
            
            multiguns_state.equipped_tools = {}
            
            local backpack = LocalPlayer:FindFirstChild("Backpack")
            if backpack then
                for _, tool in ipairs(backpack:GetChildren()) do
                    if tool:IsA("Tool") and allowed_tools[tool.Name] and tool.Parent == backpack then
                        -- Проверяем полную загрузку оружия перед экипировкой
                        if self:isToolFullyLoaded(tool) then
                            pcall(function()
                                tool.Parent = multiguns_state.character
                            end)
                        end
                    end
                end
            end
            
            if multiguns_state.character then
                for _, tool in ipairs(multiguns_state.character:GetChildren()) do
                    if tool:IsA("Tool") and allowed_tools[tool.Name] and tool:FindFirstChild("Handle") then
                        table.insert(multiguns_state.equipped_tools, tool)
                    end
                end
            end
        end
        
        -- Получение экипированных оружий
        function multiWeaponUtility:getEquippedWeapons()
            return multiguns_state.equipped_tools
        end
        
        -- Обработка добавления персонажа
        function multiWeaponUtility:onCharacterAdded(new_char)
            if not new_char or not new_char.Parent then
                return
            end
            
            multiguns_state.character = new_char
            multiguns_state.character_spawn_time = tick() -- Записываем время респавна
            
            if multiguns_state.tool_added_conn then 
                pcall(function() multiguns_state.tool_added_conn:Disconnect() end)
            end
            if multiguns_state.tool_removed_conn then 
                pcall(function() multiguns_state.tool_removed_conn:Disconnect() end)
            end
            
            multiguns_state.tool_added_conn = new_char.ChildAdded:Connect(function(child)
                if child:IsA("Tool") and allowed_tools[child.Name] and child:FindFirstChild("Handle") then
                    pcall(function()
                        table.insert(multiguns_state.equipped_tools, child)
                    end)
                end
            end)
            
            multiguns_state.tool_removed_conn = new_char.ChildRemoved:Connect(function(child)
                if child:IsA("Tool") then
                    pcall(function()
                        for i, tool in ipairs(multiguns_state.equipped_tools) do
                            if tool == child then
                                table.remove(multiguns_state.equipped_tools, i)
                                break
                            end
                        end
                    end)
                end
            end)
            
            if multiguns_state.enabled then
                pcall(function()
                    self:equipAllWeapons()
                end)
            end
        end
        
        function multiWeaponUtility:enable()
            multiguns_state.enabled = true
            multiguns_state.character = LocalPlayer.Character
            multiguns_state.last_equip_time = 0
            
            if multiguns_state.character then
                self:onCharacterAdded(multiguns_state.character)
            end
            
            -- Подключаемся к событию добавления персонажа
            if not multiguns_state.char_added_conn then
                multiguns_state.char_added_conn = LocalPlayer.CharacterAdded:Connect(function(new_char)
                    self:onCharacterAdded(new_char)
                end)
            end
            
            -- Циклическая экипировка оружий с задержкой
            multiguns_state.heartbeat_conn = RunService.Heartbeat:Connect(function()
                if not multiguns_state.enabled then return end
                if not multiguns_state.character or not multiguns_state.character.Parent then return end
                
                local now = tick()
                if now - (multiguns_state.last_equip_time or 0) >= 0.1 then -- Задержка 0.1 секунды
                    multiguns_state.last_equip_time = now
                    pcall(function()
                        self:equipAllWeapons()
                    end)
                end
            end)
        end
        
        function multiWeaponUtility:disable()
            multiguns_state.enabled = false
            
            if multiguns_state.heartbeat_conn then
                multiguns_state.heartbeat_conn:Disconnect()
                multiguns_state.heartbeat_conn = nil
            end
            
            if multiguns_state.tool_added_conn then
                multiguns_state.tool_added_conn:Disconnect()
                multiguns_state.tool_added_conn = nil
            end
            
            if multiguns_state.tool_removed_conn then
                multiguns_state.tool_removed_conn:Disconnect()
                multiguns_state.tool_removed_conn = nil
            end
            
            if multiguns_state.char_added_conn then
                multiguns_state.char_added_conn:Disconnect()
                multiguns_state.char_added_conn = nil
            end
            
            multiguns_state.equipped_tools = {}
        end
        
        _G.MultiWeaponUtility = multiWeaponUtility
    end
    
    -- Utility function to deep copy a table
    local function table_clone(orig)
        local orig_type = type(orig)
        local copy
        if orig_type == 'table' then
            copy = {}
            for orig_key, orig_value in next, orig, nil do
                copy[table_clone(orig_key)] = table_clone(orig_value)
            end
            setmetatable(copy, table_clone(getmetatable(orig)))
        else -- number, string, boolean, etc
            copy = orig
        end
        return copy
    end

    -- wallbang utility
    do
        local wallbangUtility = {}
        local wallbang_state = {
            enabled = false,
            handler = nil,
            module = nil,
            original_ignored = nil
        }
        
        function wallbangUtility:enable()
            if wallbang_state.enabled then return true end
            
            local success, err = pcall(function()
                -- Get MainModule from ReplicatedStorage
                local mainModule = game:GetService("ReplicatedStorage"):FindFirstChild("MainModule")
                if not mainModule then
                    error("MainModule not found in ReplicatedStorage")
                end
                
                -- Require the module
                local module = require(mainModule)
                if not module then
                    error("Failed to require MainModule")
                end
                
                -- Save original state
                wallbang_state.handler = mainModule
                wallbang_state.module = module
                wallbang_state.original_ignored = table_clone(module.Ignored or {})
                
                -- Set new Ignored configuration
                module.Ignored = {
                    workspace:WaitForChild("Vehicles"),
                    workspace:WaitForChild("MAP"),
                    workspace:WaitForChild("Ignored")
                }
                
                wallbang_state.enabled = true
                return true
            end)
            
            if not success then
                -- Clean up on error
                wallbangUtility:disable()
                warn("Failed to enable Wallbang:", err)
                return false, err
            end
            
            return true
        end
        
        function wallbangUtility:disable()
            if not wallbang_state.enabled then return true end
            
            local success, err = pcall(function()
                if wallbang_state.module and wallbang_state.original_ignored ~= nil then
wallbang_state.module.Ignored = table_clone(wallbang_state.original_ignored)
                end
                return true
            end)
            
            -- Always clean up state
            wallbang_state.enabled = false
            wallbang_state.module = nil
            wallbang_state.handler = nil
            wallbang_state.original_ignored = nil
            
            if not success then
                warn("Error disabling Wallbang:", err)
                return false, err
            end
            
            return true
        end
        
        function wallbangUtility:isEnabled()
            return wallbang_state.enabled == true
        end
        
        _G.WallbangUtility = wallbangUtility
    end
    
    -- silent aim prediction logic
    do
        local lastPositions, lastUpdateTimes = {}, {}
        
        local function predictPosition(player)
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return nil end
            local aimPart = player.Character.HumanoidRootPart
            local aimPartPos = aimPart.Position
            local playerId = player.UserId
            
            if not lastPositions[playerId] or not lastUpdateTimes[playerId] then
                lastPositions[playerId] = aimPartPos
                lastUpdateTimes[playerId] = tick()
                return aimPartPos
            end
            
            local currentTime = tick()
            local deltaTime = currentTime - lastUpdateTimes[playerId]
            local predictedPos
            local resolverType = _G.resolver_type
            
            if resolverType == "Velocity" then
                local velocity = aimPart.Velocity
                predictedPos = aimPartPos + Vector3.new(
                    velocity.X * _G.prediction_xz,
                    velocity.Y * _G.prediction_y,
                    velocity.Z * _G.prediction_xz
                )
            elseif resolverType == "Move direction" then
                predictedPos = aimPartPos + (player.Character.Humanoid.MoveDirection * (_G.prediction_xz * 10))
            elseif resolverType == "Calculate Cframe" then
                local distance = (aimPartPos - lastPositions[playerId]).Magnitude
                if distance < 0.001 then
                    predictedPos = aimPartPos
                else
                    local predictedDistance = (distance / deltaTime) * (0.1 * (_G.prediction_xz * 10))
                    predictedPos = aimPartPos + (aimPartPos - lastPositions[playerId]).Unit * predictedDistance
                    local yChange = (aimPartPos.Y - lastPositions[playerId].Y) / deltaTime * (0.1 * _G.prediction_y)
                    predictedPos = predictedPos + Vector3.new(0, yChange, 0)
                end
            end
            
            lastPositions[playerId] = aimPartPos
            lastUpdateTimes[playerId] = currentTime
            return predictedPos
        end
        
        _G.predictPosition = predictPosition
    end
    
    -- aimbot tracer implementation
    do
        -- Создаем drawing объекты для трейсера (outline + основная линия)
        local Drawing = Drawing or {}
        
        -- Outline линия (обводка)
        _G.aimbot_tracer_outline = Drawing.new("Line")
        _G.aimbot_tracer_outline.Visible = false
        _G.aimbot_tracer_outline.Color = Color3.new(0, 0, 0) -- черный по умолчанию
        _G.aimbot_tracer_outline.Thickness = 3.5
        _G.aimbot_tracer_outline.Transparency = 1
        _G.aimbot_tracer_outline.ZIndex = 0
        
        -- Основная линия
        _G.aimbot_tracer = Drawing.new("Line")
        _G.aimbot_tracer.Visible = false
        _G.aimbot_tracer.Color = Color3.new(1, 1, 1) -- белый по умолчанию
        _G.aimbot_tracer.Thickness = 1.5
        _G.aimbot_tracer.Transparency = 1
        _G.aimbot_tracer.ZIndex = 1
        
        -- Функция для получения handle позиции
        local function getToolHandle()
            local character = LocalPlayer.Character
            if not character then return nil end
            local tool = character:FindFirstChildOfClass("Tool")
            if not tool or not tool:FindFirstChild("Handle") then return nil end
            return tool.Handle.Position
        end
        
        -- Функция для обновления трейсера
        local function updateTracer()
            -- Двойная проверка тоглов для безопасности
            if not _G.show_aimbot or not _G.silent_aim_enabled then
                if _G.aimbot_tracer then
                    _G.aimbot_tracer.Visible = false
                end
                if _G.aimbot_tracer_outline then
                    _G.aimbot_tracer_outline.Visible = false
                end
                return
            end
            
            local targetPlayer = _G.targeting_state.current
            if not targetPlayer or not targetPlayer.Character then
                _G.aimbot_tracer.Visible = false
                _G.aimbot_tracer_outline.Visible = false
                return
            end
            
            local handlePos = getToolHandle()
            if not handlePos then
                _G.aimbot_tracer.Visible = false
                _G.aimbot_tracer_outline.Visible = false
                return
            end
            
            -- Используем глобальную функцию предсказания
            local aimPos = _G.predictPosition(targetPlayer)
            if not aimPos then
                _G.aimbot_tracer.Visible = false
                _G.aimbot_tracer_outline.Visible = false
                return
            end
            
            -- Конвертируем 3D позиции в 2D экранные координаты
            local camera = workspace.CurrentCamera
            local handleScreenPos, handleOnScreen = camera:WorldToViewportPoint(handlePos)
            local aimScreenPos, aimOnScreen = camera:WorldToViewportPoint(aimPos)
            
            if handleOnScreen and aimOnScreen then
                local fromPos = Vector2.new(handleScreenPos.X, handleScreenPos.Y)
                local toPos = Vector2.new(aimScreenPos.X, aimScreenPos.Y)
                
                -- Обновляем outline линию
                _G.aimbot_tracer_outline.From = fromPos
                _G.aimbot_tracer_outline.To = toPos
                _G.aimbot_tracer_outline.Color = _G.aimbot_outline_color
                _G.aimbot_tracer_outline.Visible = true
                
                -- Обновляем основную линию
                _G.aimbot_tracer.From = fromPos
                _G.aimbot_tracer.To = toPos
                _G.aimbot_tracer.Color = _G.aimbot_color
                _G.aimbot_tracer.Visible = true
            else
                _G.aimbot_tracer.Visible = false
                _G.aimbot_tracer_outline.Visible = false
            end
        end
        
        -- Подключаем обновление трейсера к Heartbeat
        _G.tracer_update_connection = RunService.Heartbeat:Connect(function()
            if _G.show_aimbot and _G.silent_aim_enabled then
                updateTracer()
            else
                if _G.aimbot_tracer then
                    _G.aimbot_tracer.Visible = false
                end
                if _G.aimbot_tracer_outline then
                    _G.aimbot_tracer_outline.Visible = false
                end
            end
        end)
    end
    
    -- targeting groupbox
    do
        local TargetingGroup = Tabs['Rage']:AddLeftGroupbox('             Targeting')
        
        TargetingGroup:AddLabel('select'):AddKeyPicker('TargetKey', {
            Default = 'Q',
            NoUI = false,
            Text = 'Target Key',
            Callback = function()
                local framework = _G.targeting_framework
                if framework then
                    -- Проверяем, есть ли уже цель
                    if _G.targeting_state.current then
                        -- Если есть цель, сбрасываем её
                        _G.targeting_state.current = nil
                        Library:Notify('Ragebot set to none', 2)
                    else
                        -- Если нет цели, ищем новую
                        local target = framework:GetClosestTarget()
                        if target then
                            framework:SetTarget(target)
                        else
                            Library:Notify('Notargetsfound', 2)
                        end
                    end
                end
            end
        })
        
        TargetingGroup:AddToggle('SilentAim', {
            Text = 'SilentAim',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                _G.silent_aim_enabled = value
                if value then
                    Library:Notify('on', 2)
                else
                    Library:Notify('off', 2)
                end
            end
        })
        
        -- Создаем dependency box для настроек SilentAim
        local SilentAimDepbox = TargetingGroup:AddDependencyBox()
        
        SilentAimDepbox:AddInput('PredictionXZ', {
            Default = '0.1',
            Numeric = true,
            Finished = false,
            Text = 'Prediction XZ',
            Tooltip = '>_<',
            Callback = function(value)
                _G.prediction_xz = tonumber(value) or 0.1
            end
        })
        
        SilentAimDepbox:AddInput('PredictionY', {
            Default = '0.1',
            Numeric = true,
            Finished = false,
            Text = 'Prediction Y',
            Tooltip = '>_<',
            Callback = function(value)
                _G.prediction_y = tonumber(value) or 0.1
            end
        })
        
        SilentAimDepbox:AddDropdown('ResolverType', {
            Values = {'Velocity', 'Move direction', 'Calculate Cframe'},
            Default = 1,
            Multi = false,
            Text = 'Resolver Type',
            Tooltip = '>_<',
            Callback = function(value)
                _G.resolver_type = value
            end
        })
        
        SilentAimDepbox:AddToggle('ShowAimbot', {
            Text = 'Show Aimbot',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                _G.show_aimbot = value
                -- Немедленно скрываем трейсер при отключении
                if not value then
                    if _G.aimbot_tracer then
                        _G.aimbot_tracer.Visible = false
                    end
                    if _G.aimbot_tracer_outline then
                        _G.aimbot_tracer_outline.Visible = false
                    end
                end
            end
        }):AddColorPicker('AimbotColor', {
            Default = Color3.new(1, 1, 1),
            Title = 'Aimbot Tracer Color',
            Callback = function(value)
                _G.aimbot_color = value
                if _G.aimbot_tracer then
                    _G.aimbot_tracer.Color = value
                end
            end
        }):AddColorPicker('AimbotOutlineColor', {
            Default = Color3.new(0, 0, 0),
            Title = 'Aimbot Outline Color',
            Callback = function(value)
                _G.aimbot_outline_color = value
                if _G.aimbot_tracer_outline then
                    _G.aimbot_tracer_outline.Color = value
                end
            end
        })
        
        -- Настраиваем зависимости
        SilentAimDepbox:SetupDependencies({
            { Toggles.SilentAim, true }
        })
        
        TargetingGroup:AddToggle('ForceHit', {
            Text = 'ForceHit',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                _G.forcehit_enabled = value
                if value then
                    Library:Notify('on', 2)
                else
                    Library:Notify('off', 2)
                end
            end
        })
        
        TargetingGroup:AddToggle('MagicBullets', {
            Text = 'Magic Bullets',
            Default = false,
            Tooltip = '>_<',
            Callback = function(value)
                _G.magic_bullets_enabled = value
                if value then
                    if _G.MagicBulletsFramework then
                        _G.MagicBulletsFramework.start()
                    end
                    Library:Notify('on', 2)
                else
                    if _G.MagicBulletsFramework then
                        _G.MagicBulletsFramework.stop()
                    end
                    Library:Notify('off', 2)
                end
            end
        })
        
        -- Создаем dependency box для настроек Magic Bullets
        local MagicBulletsDepbox = TargetingGroup:AddDependencyBox()
        
        MagicBulletsDepbox:AddDropdown('MagicBulletsChecks', {
            Values = {'Forcefield', 'K.O', 'Grabbed'},
            Default = {'Forcefield', 'K.O', 'Grabbed'},
            Multi = true,
            Text = 'Checks',
            Tooltip = 'Выберите какие проверки использовать',
            Callback = function(value)
                _G.magic_bullets_checks = value
            end
        })
        
        MagicBulletsDepbox:AddDropdown('MagicBulletsMode', {
            Values = {'Target', 'Killaura'},
            Default = 1,
            Multi = false,
            Text = 'Mode',
            Tooltip = 'Target - только по выбранной цели, Killaura - по всем ближайшим',
            Callback = function(value)
                _G.magic_bullets_mode = value
            end
        })
        
        -- Настраиваем зависимости
        MagicBulletsDepbox:SetupDependencies({
            { Toggles.MagicBullets, true }
        })
        
        TargetingGroup:AddToggle('MultiWeapon', {
            Text = 'Multi Weapon',
            Default = false,
            Tooltip = 'Экипирует все доступные оружия одновременно',
            Callback = function(value)
                _G.multi_weapon_enabled = value
                if value then
                    if _G.MultiWeaponUtility then
                        _G.MultiWeaponUtility:enable()
                    end
                    Library:Notify('Multi Weapon on', 2)
                else
                    if _G.MultiWeaponUtility then
                        _G.MultiWeaponUtility:disable()
                    end
                    Library:Notify('Multi Weapon off', 2)
                end
            end
        })
        
        TargetingGroup:AddToggle('Wallbang', {
            Text = 'Wallbang',
            Default = false,
            Tooltip = 'Позволяет стрелять сквозь стены',
            Callback = function(value)
                _G.wallbang_enabled = value
                if value then
                    if _G.WallbangUtility then
                        local success = _G.WallbangUtility:enable()
                        if success then
                            Library:Notify('Wallbang on', 2)
                        else
                            Library:Notify('Wallbang failed to enable', 3)
                            -- Сбрасываем тогл если не удалось включить
                            Toggles.Wallbang:SetValue(false)
                            _G.wallbang_enabled = false
                        end
                    end
                else
                    if _G.WallbangUtility then
                        _G.WallbangUtility:disable()
                    end
                    Library:Notify('Wallbang off', 2)
                end
            end
        })
        
        -- Инициализируем настройки SilentAim, ForceHit, Magic Bullets, Multi Weapon и Wallbang
        _G.silent_aim_enabled = false
        _G.forcehit_enabled = false
        _G.magic_bullets_enabled = false
        _G.magic_bullets_mode = 'Target'
        _G.magic_bullets_checks = {['Forcefield'] = true, ['K.O'] = true, ['Grabbed'] = true}
        _G.multi_weapon_enabled = false
        _G.wallbang_enabled = false
        _G.prediction_xz = 0.1
        _G.prediction_y = 0.1
        _G.resolver_type = 'Velocity'
        _G.show_aimbot = false
        _G.aimbot_color = Color3.new(1, 1, 1) -- белый по умолчанию
        _G.aimbot_outline_color = Color3.new(0, 0, 0) -- черный по умолчанию
        
        -- Auto update только при включенных функциях
        _G.target_update_connection = RunService.Heartbeat:Connect(function()
            -- Обновляем таргетинг только если включен SilentAim, ForceHit или Magic Bullets
            if (_G.silent_aim_enabled or _G.forcehit_enabled or _G.magic_bullets_enabled) and _G.targeting_framework then
                _G.targeting_framework:UpdateTarget()
            end
            -- Обновляем ForceHit цель только если ForceHit включен
            if _G.forcehit_enabled and _G.updateForceHitTarget then
                _G.updateForceHitTarget()
            end
        end)
    end
    
    -- skips groupbox
    do
        local SkipsGroup = Tabs['Rage']:AddRightGroupbox('Skips')
        
        SkipsGroup:AddToggle('SkipKO', {
            Text = 'K.O',
            Default = true,
            Tooltip = '>_<',
            Callback = function(value)
                _G.skip_ko = value
            end
        })
        
        -- Инициализируем настройку
        _G.skip_ko = true
    end
end
